The goal is to inject into the AI's context some information as part of the prompt that is passed. Ideally, this will reduce the amount of tool calls and speed up the resolution of the user request.

## EXAMPLE:
Most of the personal assistants that we can do with this setup may need or rely on the message timestamp as part of the information. This is also great so that the user can queue messages that will be lazily executed when the bot comes to life (think a time tracking app, food logger...)

## CONTEXT INJECTION STRATEGY

Context is injected by **prepending a structured header to the user message** passed via the Claude CLI `-p` flag. This preserves CLAUDE.md (which would be overridden by `--system-prompt`) and keeps context visible alongside the user request.

Format:
```prompt
# Context
- k1: v1
- k2: v2

# User Message
{user message or transcription}
```

## IMPLICIT (ALWAYS-ON) CONTEXT

A baseline context is **always injected** for every message, even if no `context` key is defined in `ccpa.config.json`. This baseline contains all available Telegram message metadata and the current datetime:

| Key | Source | Description |
|-----|--------|-------------|
| `bot.messageId` | Telegram message | Telegram message ID |
| `bot.timestamp` | Telegram message | Message Unix timestamp (seconds) |
| `bot.datetime` | Telegram message | Message datetime, ISO 8601 with timezone |
| `bot.userId` | Telegram sender | Sender's Telegram user ID |
| `bot.username` | Telegram sender | Sender's @username (if set) |
| `bot.firstName` | Telegram sender | Sender's first name |
| `bot.chatId` | Telegram chat | Chat ID |
| `bot.messageType` | Derived | `text` / `photo` / `document` / `voice` |
| `sys.datetime` | System (message-time) | Current local datetime with timezone, e.g. `2026-02-26 14:30:00 UTC+1` |
| `sys.date` | System (message-time) | Current date, `YYYY-MM-DD` |
| `sys.time` | System (message-time) | Current time, `HH:MM:SS` |
| `sys.ts` | System (message-time) | Current Unix timestamp (seconds) |
| `sys.tz` | System (message-time) | Timezone name/offset, e.g. `Europe/Berlin` |

The config's `context` key extends and/or overrides these defaults.

## CONFIGURATION

The `context` object is defined at the root of `ccpa.config.json` and can be extended per project:

```json
{
    "context": {
        "messageID": "${bot.messageId}",
        "messageTimestamp": "${bot.timestamp}",
        "localTimestamp": "#{date +\"%Y-%m-%d %H:%M:%S\"}"
    },
    "projects": [
        {
            "name": "project1"
        },
        {
            "name": "project2",
            "context": {
                "foo": "bar",
                "localTimestamp": "@{date +\"%Y%m%d%H%M%S\"}"
            }
        }
    ]
}
```

`project1` inherits the full root context. `project2` extends it with `foo` and overrides `localTimestamp` with a custom format.

## VARIABLE SUBSTITUTION

Three substitution patterns are supported in context values:

### 1. `${expression}` — App-level variable substitution

Resolution order:
1. **Environment variable**: if `expression` matches a defined env var name (e.g. `${HOME}`), use its value.
2. **Context variable**: if `expression` matches a namespaced key, resolve from the app's runtime context:
   - `${bot.X}` → resolved at **message time** from the Grammy message context (see implicit context table above)
   - `${sys.X}` → resolved at **message time** from live system state (see implicit context table above)

### 2. `#{}` — Shell command at **boot time**

Evaluated once when the bot starts. The output is stored and reused for all messages. Useful for static system info.

```json
"buildVersion": "#{git rev-parse --short HEAD}"
```

### 3. `@{}` — Shell command at **message time**

Evaluated fresh for each incoming message. Useful for live, per-message values like formatted timestamps.

```json
"localTimestamp": "@{date +\"%Y-%m-%d %H:%M:%S\"}"
```

### Security Considerations for Shell Commands (`#{}` and `@{}`)

- Shell commands are **only evaluated from `ccpa.config.json`**, never from user messages. The config is controlled by the bot operator, not end users.
- Recommend restricting config file permissions (`chmod 600 ccpa.config.json`).
- Document this clearly so operators understand the implications of adding `#{}` / `@{}` expressions.
- `@{}` commands run per-message — avoid slow or resource-intensive commands here.

## DEFAULT CONTEXT FOR `ccpa init`

When running `ccpa init`, the generated `ccpa.config.json` should include a commented-out or pre-filled `context` block demonstrating the standard keys. The implicit context (see above) is always injected, so the init template primarily serves as documentation for users who want to rename or extend keys.

Standard key names users can reference in CLAUDE.md:
- `bot.messageId` → "the message's id"
- `bot.timestamp` / `bot.datetime` → "the message timestamp / time"
- `bot.userId` → "the user's id"
- `sys.datetime` → "the current time / now"

Example: if CLAUDE.md says "save the info based on the message's id", Claude Code can reconcile this to `bot.messageId` from the context.

## CONTEXT HOOK

Two hook locations are supported, both named `context.mjs` inside a `.ccpa/hooks/` directory:

1. **Global hook**: `{configDir}/.ccpa/hooks/context.mjs` — sibling to `ccpa.config.json`. Applies to all projects.
2. **Project hook**: `{project.cwd}/.ccpa/hooks/context.mjs` — specific to a single project.

Both hooks are **hot-reloaded on every message** via dynamic `import()` with a cache-busting query string (e.g. `?t=<timestamp>`). This means:
- Hooks can be added, modified, or removed without restarting the bot.
- Claude Code itself (or any other process) can modify hook files at runtime and the changes take effect on the next message.

When both hooks exist, they are **chained**: the global hook runs first, and its output is passed as input to the project hook.

### Interface

Each hook exports a single default async function that receives the context object and returns the (optionally modified) context:

```js
// {configDir}/.ccpa/hooks/context.mjs  (global)
// {project.cwd}/.ccpa/hooks/context.mjs  (project)
export default async (context) => ({
  ...context,
  project: "my-tracker",
  user: await fetchUserProfile(context["bot.userId"])
})
```

- **Input**: a `Record<string, string>` context (after implicit defaults, config merging, and variable substitution — or after the previous hook in the chain)
- **Output**: a `Record<string, string>` — the context passed to the next hook or to Claude
- The function may be async (awaited by the bot)
- If a hook throws, the bot should log the error and fall back to the pre-hook context (do not crash the message handler)
- If a hook file does not exist, it is silently skipped

### Loading (per message)

```ts
async function loadAndRunHook(hookPath: string, context: Record<string, string>, logger: Logger): Promise<Record<string, string>> {
  if (!existsSync(hookPath)) return context
  try {
    const { default: hook } = await import(`${hookPath}?t=${Date.now()}`)
    return await hook(context)
  } catch (err) {
    logger.error({ err, hookPath }, "Context hook failed, using pre-hook context")
    return context
  }
}

// Execution order: global first, then project
context = await loadAndRunHook(join(configDir, ".ccpa/hooks/context.mjs"), context, logger)
context = await loadAndRunHook(join(config.cwd, ".ccpa/hooks/context.mjs"), context, logger)
```

The hook is loaded with Node.js native dynamic `import()` — no transpilation or build step required for the user. The file must use ESM `export default` syntax. `.mjs` extension guarantees ESM regardless of the project's `package.json` `"type"` field. The `?t=<timestamp>` query string bypasses the Node.js module cache, enabling hot-reload.

### Security

Same operator-controlled trust level as `#{}` / `@{}` shell commands. Hook files are arbitrary JavaScript executed in the bot process — document this clearly and recommend restricting file permissions.

## IMPLEMENTATION NOTES

- Context resolution happens in the executor layer (`src/claude/executor.ts`) before building the `-p` prompt string.
- All handlers (text, photo, document, voice) pass the Grammy context object to the executor so bot variables can be resolved.
- `sys.*` variables are evaluated fresh per message (at prompt-construction time).
- `#{}` shell commands are evaluated once at startup and cached in memory for the lifetime of the bot process.
- `@{}` shell commands are evaluated at prompt-construction time for each message.
- Context hooks are hot-reloaded via `import()` with cache-busting on every message. Global hook (`{configDir}/.ccpa/hooks/context.mjs`) runs first, project hook (`{project.cwd}/.ccpa/hooks/context.mjs`) runs second. Both are optional and independent.
- The `configDir` path must be available at message time so the executor can locate the global hook. Store it in `ProjectContext` or `ResolvedProjectConfig`.
- The Zod schema for config validation should accept `context` as `Record<string, string>` at both root and project level.
- Update the README to document: the implicit context keys, variable substitution patterns (`${}`, `#{}`, `@{}`), the `context` config key with inheritance example, and the two-level `.ccpa/hooks/context.mjs` hook system.
