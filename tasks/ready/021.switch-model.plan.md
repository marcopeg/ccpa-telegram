# 021 — /model command: Development Plan

## Phase 1: Foundation — Types and embedded model data

### Step 1.1: Define model types

**File:** `src/engine/types.ts`

Add new types to the existing engine types file:

- `ModelEntry` — `{ id: string; displayName: string; description?: string }`
- `ModelListResult` — `{ engine: EngineName; models: ModelEntry[]; lastUpdatedAt: string; source: "cli" | "http" | "cache" | "embedded" }`

### Step 1.2: Create `models.md`

**File:** `models.md` (repo root)

Create a structured markdown file with curated model data for all 5 engines. Use a parseable format (e.g. headings for engine names, tables or structured lists for models). Each entry includes: model ID, display name, and a brief description.

Populate with current data from research:

- **Claude**: claude-opus-4-6, claude-sonnet-4-6, claude-haiku-4-5, claude-sonnet-4-5, claude-opus-4-5, claude-opus-4-1, claude-sonnet-4, claude-opus-4
- **Copilot**: gpt-5, gpt-5-mini, gpt-4.1, o3, o3-mini, o4-mini, claude-sonnet-4.5, claude-opus-4.5, gemini-2.5-pro, gemini-3-flash, gemini-3-pro
- **Codex**: gpt-5.3-codex, gpt-5.3-codex-spark, codex-mini-latest
- **OpenCode**: sourced via `opencode models` output; include common provider/model combos
- **Cursor**: claude-4-sonnet-thinking, o3, claude-4-opus-thinking, and others

### Step 1.3: Create codegen script

**File:** `scripts/embed-models.ts`

A script that:

1. Reads `models.md` from the repo root.
2. Parses the structured markdown into typed model data per engine.
3. Generates `src/engine/models-data.generated.ts` exporting a `Record<EngineName, ModelEntry[]>` constant and a `MODELS_LAST_UPDATED` date string.

### Step 1.4: Update build scripts

**File:** `package.json`

- Add `"generate:models": "tsx scripts/embed-models.ts"` script.
- Update `"build"` to run the codegen first: `"tsx scripts/embed-models.ts && tsc && chmod +x dist/cli.js"`.
- Update `"start"` (dev) to ensure the generated file exists: add `"prestart": "tsx scripts/embed-models.ts"`.
- Add `src/engine/models-data.generated.ts` to `.gitignore` — OR commit the generated file to simplify CI (decision: **commit it**, since `models.md` changes are infrequent and we want `tsc` to work standalone).

---

## Phase 2: Adapter `listModels()` implementation

### Step 2.1: Extend `EngineAdapter` interface

**File:** `src/engine/types.ts`

Add to the `EngineAdapter` interface:

```ts
listModels(): Promise<ModelListResult>;
```

### Step 2.2: Create shared helpers

**File:** `src/engine/models-fetch.ts`

- `fetchModelsFromModelsDev(provider: string): Promise<ModelEntry[]>` — HTTP GET `https://models.dev/api.json`, filter by provider, map to `ModelEntry[]`.
- `parseCliModelOutput(output: string): ModelEntry[]` — Parse CLI stdout into model entries (used by Cursor and OpenCode adapters).
- `getEmbeddedModels(engine: EngineName): ModelEntry[]` — Import from `models-data.generated.ts`.

### Step 2.3: Implement `listModels()` per adapter

Each adapter implements `listModels()` following the strategy from the task:

**Claude** (`src/engine/adapters/claude.ts`):
1. Try: `fetchModelsFromModelsDev("anthropic")`
2. Fallback: `getEmbeddedModels("claude")`

**Codex** (`src/engine/adapters/codex.ts`):
1. Try: `fetchModelsFromModelsDev("openai")` filtered to codex-relevant models
2. Fallback: `getEmbeddedModels("codex")`

**Copilot** (`src/engine/adapters/copilot.ts`):
1. Hardcoded only: `getEmbeddedModels("copilot")`

**OpenCode** (`src/engine/adapters/opencode.ts`):
1. Try: run `opencode models` via `execSync`, parse output
2. Fallback: `getEmbeddedModels("opencode")`

**Cursor** (`src/engine/adapters/cursor.ts`):
1. Try: run `agent models` or `agent --list-models` via `execSync`, parse output
2. Fallback: `getEmbeddedModels("cursor")`

---

## Phase 3: Model cache service

### Step 3.1: Create cache module

**File:** `src/engine/model-cache.ts`

Exports:

- `ModelCache` class (or plain functions) managing `.hal/cache/models.json` under `configDir`.
- Constructor/init takes `configDir`.

### Step 3.2: Cache file format

```json
{
  "fetchedAt": "2026-03-01T12:00:00Z",
  "engines": {
    "claude": { "models": [...], "lastUpdatedAt": "...", "source": "http" },
    "copilot": { "models": [...], "lastUpdatedAt": "...", "source": "embedded" }
  }
}
```

### Step 3.3: Implement cache operations

- `readCache(configDir): CacheData | null` — Read and parse `.hal/cache/models.json`. Return null if missing or unparseable.
- `writeCache(configDir, data: CacheData): void` — Write cache file (ensure `.hal/cache/` dir exists).
- `isCacheValid(cache: CacheData): boolean` — True if `fetchedAt` is within 24 hours.

### Step 3.4: Implement fetch orchestration

- `resolveModels(engine: EngineName, adapter: EngineAdapter, configDir: string): Promise<ModelListResult>`:
  1. Check in-memory cache (populated at boot or by cron).
  2. If miss → check file cache (`readCache`); if valid, use it.
  3. If miss → call `adapter.listModels()`.
  4. If success → update in-memory + file cache.
  5. If failure → use stale file cache if available.
  6. If no cache → use embedded data from `models-data.generated.ts`.

### Step 3.5: Implement hourly refresh

- `startModelCacheRefresh(engines: Map<EngineName, EngineAdapter>, configDir: string): { stop: () => void }`:
  - `setInterval` every 60 minutes.
  - For each engine in the map, call `adapter.listModels()` and update cache.
  - Use `.unref()` so the interval doesn't keep the process alive (same pattern as rate-limit cleanup).
  - Return a `stop()` handle for shutdown.

---

## Phase 4: Boot-time validation

### Step 4.1: Create validation function

**File:** `src/engine/model-validation.ts`

- `validateEngineModels(projects: ResolvedProjectConfig[], modelCache: CacheData): { valid: boolean; errors: string[] }`:
  - For each project where `engineModel` is defined (not undefined/null):
    - Look up the model list for that project's `engine` from the cache.
    - Check if `engineModel` exists in the list of model IDs.
    - If not found, add an error: `Project "${name}": model "${engineModel}" is not valid for engine "${engine}". Available: [...]`.
  - Return all errors collected across all projects.

### Step 4.2: Integrate into boot flow

**File:** `src/cli.ts`

In `runBotsForConfig()`, after resolving all project configs and before starting bots:

1. Collect the set of unique engines actually used.
2. Fetch/resolve model lists for those engines (populates cache).
3. Call `validateEngineModels()`.
4. If errors → log each error, then `process.exit(1)`.
5. Start the hourly cache refresh interval.
6. Return the refresh handle alongside bot handles for shutdown cleanup.

---

## Phase 5: Config writer utility

### Step 5.1: Create config writer

**File:** `src/config-writer.ts`

- `updateProjectModel(configDir: string, projectIdentifier: { name?: string; cwd: string }, engine: EngineName, model: string): void`:
  1. Determine target file: if `hal.config.local.json` exists in `configDir`, use it; otherwise use `hal.config.json`.
  2. Read the target file as JSON (or `{}` if local doesn't exist yet — but it must exist per the "if available" rule).
  3. Find the matching project entry by `name` or `cwd`.
  4. Set `project.engine.name` = engine name (explicit, even if inherited from globals).
  5. Set `project.engine.model` = selected model ID.
  6. Write the file back with `JSON.stringify(data, null, 2)`.

### Step 5.2: Handle edge cases

- If the project doesn't exist in the local config file, create a minimal project entry with `cwd`, `engine.name`, and `engine.model`.
- Preserve all other existing fields in the file.
- If the local file has a `projects` array (multi-project local), patch the correct entry.
- If the local file is a single-project partial override (no `projects` array), patch at root level.

---

## Phase 6: `/model` command and Telegram UI

### Step 6.1: Update config schema

**File:** `src/config.ts`

- Add `model: SimpleCommandConfigSchema` to `CommandsConfigSchema`.
- Add `model: { enabled: boolean; message?: string }` to the resolved commands type.
- Default: `enabled: true`.

### Step 6.2: Create `/model` command handler

**File:** `src/bot/commands/model.ts`

`createModelHandler(ctx: ProjectContext)` returns `(gramCtx: Context) => Promise<void>`:

1. Get current engine and model from `ctx.config`.
2. Resolve model list via `resolveModels()` (cache → fetch → embedded).
3. Build an `InlineKeyboard`:
   - One button per model, each on its own `.row()`.
   - Label: `"✓ displayName"` for the current model, `"displayName"` for others.
   - If a description is available, append a truncated version: `"displayName — brief desc"`.
   - Callback data: `"md:select:<modelId>"` (prefix `md:` for "model").
4. Send message: `"Select a model for {engineName}:\n\nLast updated: {lastUpdatedAt}"` with `reply_markup: keyboard`.

### Step 6.3: Create model callback handler

**File:** `src/bot/commands/model-callback.ts`

`createModelCallbackHandler(ctx: ProjectContext)` returns `(gramCtx: Context, next: NextFunction) => Promise<void>`:

1. Check `data?.startsWith("md:")` — if not, call `next()`.
2. Parse `md:select:<modelId>`.
3. Call `updateProjectModel()` from the config writer.
4. Answer callback query: `"Model switched to {displayName}"`.
5. Edit the original message to confirm: `"Model changed to {displayName}. The change will take effect shortly."`.
6. Remove the inline keyboard (`reply_markup: undefined`).

### Step 6.4: Register command and callback

**File:** `src/bot.ts`

Following the existing pattern:

```ts
if (cmd.model.enabled) {
  bot.command("model", createModelHandler(projectCtx));
  bot.on("callback_query:data", createModelCallbackHandler(projectCtx));
}
```

Note: the callback handler registration must be compatible with existing callback handlers (git, reset). Each uses prefix-based routing and calls `next()` when it doesn't handle the data.

### Step 6.5: Add to built-in command list

**File:** `src/bot/commands/loader.ts`

- Add `{ command: "model", description: "Switch the AI model" }` to `BUILTIN_COMMANDS`.
- Add `model: "model"` entry in `BUILTIN_ENABLED_MAP`.

### Step 6.6: Update help text

**File:** `src/bot/commands/help.ts` (or `message.ts`)

Ensure `/model` appears in the help output when enabled.

---

## Phase 7: Integration and wiring

### Step 7.1: Wire cache refresh into lifecycle

**File:** `src/cli.ts`

- In `runBotsForConfig()`: after validation passes, call `startModelCacheRefresh()` and store the handle.
- In the shutdown handler (`SIGINT`/`SIGTERM`): call `refreshHandle.stop()`.
- In the hot-reload handler: stop old refresh, start new one after reloading bots.

### Step 7.2: Update example config

**File:** `examples/hal.config.json`

Add `"model": { "enabled": true }` to the commands section of the example project config, alongside `"git"`.

### Step 7.3: Verify hot-reload integration

Confirm that:

- After config write by the `/model` callback, the config watcher fires.
- The hot-reload stops bots, reloads config (with new model), recreates engines with the new model, and restarts bots.
- The new model is used for subsequent engine calls.

---

## Dependency graph

```
Phase 1 (types + models.md + codegen)
  └─► Phase 2 (adapter listModels)
        └─► Phase 3 (cache service)
              ├─► Phase 4 (boot validation)
              └─► Phase 6 (command + UI)
                    └─► Phase 5 (config writer) ◄── used by Phase 6.3
                          └─► Phase 7 (integration)
```

## Files created (new)

| File | Purpose |
|------|---------|
| `models.md` | Curated model metadata at repo root |
| `scripts/embed-models.ts` | Codegen: `models.md` → TypeScript |
| `src/engine/models-data.generated.ts` | Generated embedded model data |
| `src/engine/models-fetch.ts` | HTTP + CLI model fetching helpers |
| `src/engine/model-cache.ts` | Cache read/write/refresh logic |
| `src/engine/model-validation.ts` | Boot-time engine+model validation |
| `src/config-writer.ts` | Config file patching utility |
| `src/bot/commands/model.ts` | `/model` command handler |
| `src/bot/commands/model-callback.ts` | Inline keyboard callback handler |

## Files modified

| File | Changes |
|------|---------|
| `src/engine/types.ts` | Add `ModelEntry`, `ModelListResult`, `listModels()` to interface |
| `src/engine/adapters/*.ts` | Implement `listModels()` in all 5 adapters |
| `src/engine/registry.ts` | No changes expected |
| `src/config.ts` | Add `model` to commands schema + resolved type |
| `src/cli.ts` | Boot validation, cache refresh lifecycle |
| `src/bot.ts` | Register `/model` command + callback handler |
| `src/bot/commands/loader.ts` | Add `model` to built-in commands list |
| `package.json` | Add codegen scripts |
| `examples/hal.config.json` | Add `model` command example |
