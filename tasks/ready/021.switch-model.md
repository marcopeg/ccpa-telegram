# 021 — /model command: switch the active model at runtime

## Summary

Add a new built-in `/model` command that presents the list of available models for the project's engine via Telegram inline keyboard buttons, and lets the user pick a new model. The change is persisted to the config file and takes effect immediately via hot-reload.

## Context

- The project supports 5 engines: `claude`, `copilot`, `codex`, `opencode`, `cursor`.
- Configuration is per-project (not per-user). Changing the model affects all users of that project.
- Hot-reload (task 015) is implemented — config file changes are picked up automatically.
- Grammy `InlineKeyboard` is already used in the codebase (e.g. `/git_clean`).

## Requirements

### 1. Adapter interface: `listModels()` method

Add a `listModels()` method to the `EngineAdapter` interface. Each adapter implements it using the best available source:

| Engine       | Primary source                                          | Fallback   |
|--------------|---------------------------------------------------------|------------|
| **Cursor**   | CLI: `agent models` or `--list-models`                  | Hardcoded  |
| **OpenCode** | CLI: `opencode models`                                  | Hardcoded  |
| **Claude**   | HTTP: `models.dev/api.json` filtered to `anthropic`     | Hardcoded  |
| **Codex**    | HTTP: `models.dev/api.json` filtered to `openai` (codex)| Hardcoded  |
| **Copilot**  | Hardcoded                                               | —          |

The method should return a list of model entries, each containing at least: `id`, `displayName`, `description`.

Every response must include a `lastUpdatedAt` timestamp indicating when the model list was last refreshed.

### 2. Model metadata: `models.md`

Maintain a `models.md` file at the repository root containing curated descriptions for known models (name, brief capability/usecase description) organized by engine.

This file is:
- Parsed at **build time** and embedded into the application.
- Used as the source for model descriptions shown in the Telegram UI.
- Used as the **hardcoded fallback** when dynamic sources are unavailable.
- Manually updated as part of development/releases.

### 3. Model cache: `.hal/cache/models.json`

Implement a caching layer for model lists:

- **At boot**: fetch fresh model lists for all engines actually used in the config. Cache the result to `.hal/cache/models.json` with a timestamp.
- **Subsequent boots**: if cache exists and is **< 24 hours old**, use it instead of fetching. This makes reboots fast after the first one.
- **Runtime refresh**: set an hourly cron (e.g. `setInterval`) to refresh the cache in the background, keeping it fresh during the process lifetime.
- **Graceful degradation**: if a fetch fails (network down, CLI unavailable), fall back to the cache (even if stale), then to the hardcoded list from `models.md`.

### 4. Boot-time validation: engine + model combo

At boot, after resolving the model list (from cache or fresh fetch):

- For **every project**, validate that the configured `engineModel` exists in the model list for that project's engine.
- If a project defines a model that is not valid for its engine, **log the error** (for all invalid projects) and **abort boot**.
- If no model is configured (relying on engine defaults), validation passes.

### 5. The `/model` command

Register a new built-in command `/model`:

- Fetch the model list for the current project's engine (from cache, falling back to a fresh fetch).
- Display an **inline keyboard** (Telegram buttons) with one button per model.
- Each button shows: model display name + brief description (if available).
- The **currently active model** is highlighted (e.g. prefixed with a checkmark ✓ or similar marker).
- Show the "last updated at" timestamp for the model list somewhere in the message.

### 6. Config persistence on model selection

When the user picks a model:

- **Write to `hal.config.local.json`** if it exists; otherwise write to `hal.config.json`.
- When setting a model at project level, **always also set the engine name explicitly** at project level — even if it was previously inherited from globals. This prevents a model becoming invalid after a global engine change.
- The config file write must preserve existing structure (read → patch → write).
- The hot-reload watcher picks up the change and the new model takes effect immediately.

### 7. Command registration

- The `/model` command should follow the same pattern as other built-in commands (`start`, `help`, `reset`, `clean`).
- It should be toggleable via the `commands` config section (e.g. `commands.model.enabled`).
- Callback queries for inline keyboard interactions need a handler (similar to `git` callback handler pattern).

## Acceptance Criteria

- [ ] `EngineAdapter` interface has a `listModels()` method; all 5 adapters implement it.
- [ ] `models.md` exists at repo root with curated model info; parsed at build time.
- [ ] Model cache is written to `.hal/cache/models.json`; respected for 24h; refreshed hourly at runtime.
- [ ] Boot aborts with clear error messages if any project has an invalid engine+model combo.
- [ ] `/model` command shows inline keyboard with models, highlights current, shows last-updated timestamp.
- [ ] Selecting a model writes to the config file (local if available, else base) with explicit engine name.
- [ ] Hot-reload picks up the config change and the new model is used for subsequent prompts.
- [ ] Fallback chain works: dynamic source → cache → hardcoded (`models.md`).

## Dependencies

- Task 015 (hot-reload) — completed.

## Notes

- Scope is project-level, not per-user. A model change affects all users of that project.
- User-level model preferences may be considered in a future task.
