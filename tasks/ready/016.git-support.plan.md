# Development plan: Git support (016)

Plan for implementing task [016.git-support.md](./016.git-support.md). Phases are ordered so that config and command registration are in place before adding handlers that depend on them.

---

## Phase 1: Config schema and resolution

**Goal:** Add `git.enabled` to config (globals and project), resolve to a boolean on `ResolvedProjectConfig`.

### Steps

1. **Add `git` to Zod schemas (config.ts)**
   - In `GlobalsFileSchema`: add `git: z.object({ enabled: z.boolean() }).partial().optional()`.
   - In `ProjectFileSchema`: add the same `git` field so both globals and project can set it.

2. **Extend `ResolvedProjectConfig`**
   - Add `gitEnabled: boolean` to the interface.
   - In `resolveProjectConfig`, resolve `gitEnabled` from `project.git?.enabled ?? globals.git?.enabled ?? false` (project overrides globals; default false).

3. **Verify**
   - Ensure existing configs without `git` still load (optional field).
   - Optionally add a test or manual check that `gitEnabled` is true when `"git": { "enabled": true }` is set in globals or project.

---

## Phase 2: Command loader and Telegram registration

**Goal:** When `gitEnabled` is true, include the four git commands in the list sent to `setMyCommands`; keep registration in sync on startup and on watcher republish.

### Steps

1. **Define git command entries (loader.ts)**
   - Add a constant `GIT_COMMANDS: CommandEntry[]` with the four commands and their Telegram descriptions, e.g.:
     - `git_init` — "Initialize git repo and first commit"
     - `git_status` — "Show git status"
     - `git_commit` — "Stage and commit (message optional)"
     - `git_clean` — "Revert uncommitted changes for file(s)"

2. **Extend `loadCommands` signature**
   - Add an optional 5th parameter `options?: { gitEnabled?: boolean }` (or a single `gitEnabled?: boolean` to avoid breaking call sites unnecessarily). When `gitEnabled === true`, after seeding `BUILTIN_COMMANDS`, add all `GIT_COMMANDS` to the same map (so they appear in the merged list and are registered with Telegram).

3. **Update call sites**
   - **bot.ts**: When calling `loadCommands` after bot start, pass `config.gitEnabled`. When `config.gitEnabled` is true, the returned list will include git commands; no change to `setMyCommands` call itself.
   - **watcher.ts**: Add a parameter `gitEnabled?: boolean` to `startCommandWatcher`. In `republish()`, call `loadCommands(..., { gitEnabled })` (or the chosen signature). This requires the caller of `startCommandWatcher` to pass the flag.

4. **Pass `gitEnabled` into watcher (bot.ts)**
   - In `startBot`, call `startCommandWatcher(bot, config.cwd, config.configDir, logger, skillsDir, config.gitEnabled)` (or add as options object if you prefer). Update `startCommandWatcher` signature and implementation to accept and use this.

5. **Verify**
   - With `git.enabled: true`, run the bot and confirm the four git commands appear in Telegram’s command menu. With `git.enabled: false` or omitted, confirm they do not appear.

---

## Phase 3: Git helpers module

**Goal:** Central place to run git commands in a given `cwd` (project directory). All handlers will use this instead of ad-hoc `exec`/`spawn`.

### Steps

1. **Create `src/git/index.ts` (or `src/git/runner.ts`)**
   - Implement helpers (using `child_process.execSync` or `spawnSync` with `cwd`; prefer sync for simplicity in handlers, or async if you want non-blocking):
     - `isRepo(cwd: string): boolean` — e.g. run `git rev-parse --is-inside-work-tree` and check exit code / stdout.
     - `init(cwd: string): void` — `git init`; throw on failure.
     - `firstCommit(cwd: string, message?: string): void` — `git add .` then `git commit -m "<message>"` (default message e.g. "Initial commit").
     - `status(cwd: string): string` — `git status` (and optionally `--short`) and return stdout.
     - `getModifiedFiles(cwd: string): string[]` — parse `git status --short` (or porcelain) to list paths with uncommitted changes (working tree and/or staged). Return array of file paths relative to `cwd`.
     - `restore(cwd: string, paths: string[]): void` — `git restore -- <path1> <path2> ...`; throw on failure.
     - `addAndCommit(cwd: string, message: string): void` — `git add .` and `git commit -m "<message>"`; throw on failure.
   - Ensure all commands run with `{ cwd }` so they execute in the project directory. Handle errors (e.g. not a repo, nothing to commit) and either throw or return a result type as appropriate for callers.

2. **Edge cases**
   - `getModifiedFiles`: handle empty repo, no changes (return empty array). Consider whether to include untracked files or only modified/tracked; task says "uncommitted changes", so include modified and optionally staged; clarify "reset all" as "revert all working-tree (and staged) changes" for listed files.
   - `restore`: if paths array is empty, no-op or throw; document behavior.

3. **Verify**
   - Unit or integration tests in a temp dir: init, first commit, status, getModifiedFiles, restore (optional). Or manually test from a small script.

---

## Phase 4: `/git_init` handler

**Goal:** Implement the `/git_init` command and wire it only when `gitEnabled` is true.

### Steps

1. **Create handler (e.g. `src/bot/commands/gitInit.ts`)**
   - Export `createGitInitHandler(projectCtx: ProjectContext)` that returns an async handler `(gramCtx: Context) => Promise<void>`.
   - In handler: read `config.cwd`. If `isRepo(config.cwd)`, reply e.g. "Already a git repository." and return. Otherwise call `init(config.cwd)` then `firstCommit(config.cwd)`, then reply with success (e.g. "Git repository initialized and first commit created."). On error (e.g. git not installed), reply with a user-friendly message and log the error.

2. **Wire in bot.ts**
   - When `config.gitEnabled` is true: `bot.command("git_init", createGitInitHandler(projectCtx))`.

3. **Verify**
   - In a project without git: send `/git_init`, then check repo exists and has one commit. Send `/git_init` again and confirm "Already a git repository."

---

## Phase 5: `/git_status` handler

**Goal:** Run `git status` in the project directory and send the output to the user.

### Steps

1. **Create handler (e.g. `src/bot/commands/gitStatus.ts`)**
   - `createGitStatusHandler(projectCtx)`. If not `isRepo(config.cwd)`, reply "Not a git repository. Use /git_init to initialize." Otherwise call `status(config.cwd)` and reply with the output. Optionally wrap in a code block or escape Markdown to avoid parsing issues (`parse_mode` or pre/code).

2. **Wire in bot.ts**
   - When `config.gitEnabled`: `bot.command("git_status", createGitStatusHandler(projectCtx))`.

3. **Verify**
   - In a repo: send `/git_status` and confirm output matches terminal `git status`. Outside a repo: confirm friendly message.

---

## Phase 6: `/git_commit` handler

**Goal:** Stage all changes and commit; use user-provided message or AI-generated message when none is passed.

### Steps

1. **Create handler (e.g. `src/bot/commands/gitCommit.ts`)**
   - Parse the command text: if the user sent a message after the command (e.g. `/git_commit fix bug`), use that as the commit message (trim, and handle empty).
   - If **message provided**: call `addAndCommit(config.cwd, message)`, reply success or error.
   - If **no message**: (1) Ensure we’re in a repo and there are changes (e.g. run `status` or `diff`). If nothing to commit, reply e.g. "Nothing to commit." (2) Get diff/status text (e.g. `git diff --staged` and `git status` or `git diff`). (3) Call `createAgent(projectCtx).call("Generate a short, single-line commit message for these changes. Reply with only the message, no quotes or explanation.\n\n" + diffText, { continueSession: false })`. (4) Use the returned string as the commit message (strip newlines/quotes if needed), then `addAndCommit(config.cwd, generatedMessage)`. (5) Reply with e.g. "Committed: <message>." On any error (no changes, agent failure, commit failure), reply with a clear message and log.

2. **Wire in bot.ts**
   - When `config.gitEnabled`: `bot.command("git_commit", createGitCommitHandler(projectCtx))`.

3. **Verify**
   - With message: `/git_commit fix bug` → commit created with that message. Without message: make a change, send `/git_commit` → AI generates message and commit is created. With no changes: confirm "Nothing to commit."

---

## Phase 7: `/git_clean` — direct path and UI flow

**Goal:** Revert uncommitted changes. When a single parseable file is given, revert it and reply. When no file or unparseable argument, show file list with inline keyboard, then confirm step with Confirm/Cancel.

### Steps

1. **Create handler module (e.g. `src/bot/commands/gitClean.ts`)**
   - **Direct path:** If the command has one argument that can be parsed as a single file path (no spaces, or quoted), resolve it relative to `config.cwd`, check it exists in the list of modified files (or trust and call `restore`). Call `restore(config.cwd, [path])`, reply e.g. "Reverted changes for &lt;path&gt;." If path is invalid or not in modified list, reply with an error or fall through to the UI flow.
   - **UI flow (no file or unparseable):** Get `files = getModifiedFiles(config.cwd)`. If empty, reply "No files with uncommitted changes." and return. Otherwise send a message listing the files and attach an **inline keyboard**: one button per file (label: short path or filename; `callback_data` must identify the choice within 64 bytes — see below) and one button "Reset all" (`callback_data` e.g. `gc:all`). Store state for this user so the callback handler can know which files to revert and which project (cwd). Option: store in a module-level `Map<userId, { cwd: string, files: string[], timestamp?: number }>`. When building buttons, use indices: `callback_data: "gc:<index>"` for each file and `"gc:all"` for reset all. When the user clicks, the callback handler will look up state by `userId`, get `cwd` and the file(s) (one path for index, or all for "all"), then show the confirm step.

2. **Confirm step (same module or shared)**
   - Send (or edit) a message: list the file(s) that will be reset, text "Confirm reset these files and lose the changes?" with two buttons: "Confirm" and "Cancel". Use `callback_data` e.g. `gcc:confirm` and `gcc:cancel`; the callback handler must know which files and which cwd — so store in state: when moving from "file list" to "confirm", set `state[userId] = { cwd, files: chosenFiles, step: 'confirm' }`. When the user clicks Confirm, run `restore(cwd, files)`, clear state, reply "Reverted: …". When Cancel, clear state and reply "Cancelled." Use a short-lived state (e.g. clear after 5–10 minutes or on cancel) to avoid leaking memory.

3. **callback_data size**
   - Telegram limits `callback_data` to 64 bytes. Do not put full paths in it. Use indices into the stored `files` array (e.g. `gc:0`, `gc:1`, `gc:all`) and keep the full list in server-side state keyed by `userId` (and optionally `chatId` if you need multi-chat). For "Confirm"/"Cancel", use `gcc:confirm` and `gcc:cancel`; the handler already has the files in state.

4. **Wire command in bot.ts**
   - When `config.gitEnabled`: `bot.command("git_clean", createGitCleanHandler(projectCtx))`.

---

## Phase 8: Callback query handler for `/git_clean` UI

**Goal:** Handle inline keyboard button presses for file selection and confirm/cancel.

### Steps

1. **Register `callback_query` handler (bot.ts)**
   - When `config.gitEnabled`, add `bot.on("callback_query", createGitCleanCallbackHandler(projectCtx))`. Only handle callback_data that starts with the git_clean prefix (e.g. `gc:` or `gcc:`); if other features use callback_query later, dispatch by prefix and ignore others.

2. **Implement `createGitCleanCallbackHandler` (in gitClean.ts or a dedicated callback file)**
   - Parse `callback_query.data`. If it doesn’t start with `gc`, call `ctx.answerCallbackQuery()` and return (or let other handlers deal with it).
   - **File selection (`gc:<index>` or `gc:all`):** Get `userId` from `callback_query.from.id`. Look up state[userId]. If no state or state is stale, answerCallbackQuery with "Session expired" and return. If `gc:all`, set chosenFiles = state.files; if `gc:<i>`, set chosenFiles = [state.files[parseInt(i)]]. Update state to `{ ...state, step: 'confirm', files: chosenFiles }`. Edit the message (or send new one) to show "Files to reset: …" and "Confirm reset these files and lose the changes?" with [Confirm] [Cancel] buttons. Use `ctx.answerCallbackQuery()` to dismiss the loading state.
   - **Confirm/Cancel (`gcc:confirm`, `gcc:cancel`):** Look up state[userId]. If cancel: clear state, edit/send "Cancelled.", answerCallbackQuery. If confirm: run `restore(state.cwd, state.files)`, clear state, edit/send "Reverted: …", answerCallbackQuery. On restore failure, reply with error and clear state.

3. **Multi-select (optional)**
   - Task says "user can select which file(s) to revert". Simplest is one click = one file (or "Reset all"). If you want multi-select, you could show the same list again and toggle selection (e.g. state.filesSelected: Set<index>), then a "Done" button that goes to confirm. For the first version, single file or "Reset all" is enough; multi-select can be a follow-up.

4. **Verify**
   - Send `/git_clean` with no args → see list of modified files and buttons. Click one file → see confirm step. Click Confirm → file is reverted and message updated. Click Cancel → "Cancelled." Send `/git_clean` with a valid file path → file reverted without UI. Send `/git_clean` with invalid path → fall back to UI or error message.

---

## Phase 9: Integration and edge cases

**Goal:** Ensure all commands behave correctly when not in a repo, and help text stays in sync.

### Steps

1. **Not a repo**
   - For `/git_status`, `/git_commit`, `/git_clean`: if `!isRepo(config.cwd)`, reply with a single line suggesting `/git_init` and do not run git. Document in code or task.

2. **Help / command list**
   - The descriptions in `GIT_COMMANDS` are already used for `setMyCommands`. If there is a `/help` handler that lists commands, ensure it includes git commands when `config.gitEnabled` (the command list comes from `loadCommands`, which now includes git commands when enabled, so help may already show them if it uses the same list).

3. **Lint and tests**
   - Run `pnpm run lint` and fix any issues. Add tests if desired for git helpers or critical handler paths.

4. **Docs**
   - Update README or user-facing docs to mention the `git.enabled` config and the four commands (optional, can be a follow-up).

---

## Summary and order

| Phase | Description |
|-------|-------------|
| 1 | Config: `git.enabled` in schema and `ResolvedProjectConfig.gitEnabled` |
| 2 | Loader: `GIT_COMMANDS`, `loadCommands(..., { gitEnabled })`, watcher and bot pass flag |
| 3 | Git helpers: `src/git/` module with `isRepo`, `init`, `firstCommit`, `status`, `getModifiedFiles`, `restore`, `addAndCommit` |
| 4 | `/git_init` handler and wire in bot |
| 5 | `/git_status` handler and wire in bot |
| 6 | `/git_commit` handler (with optional AI message) and wire in bot |
| 7 | `/git_clean` handler (direct path + UI flow with file list and state) |
| 8 | Callback query handler for git_clean (file selection → confirm/cancel) |
| 9 | Edge cases (not a repo, help, lint, docs) |

Dependencies: 1 → 2; 3 → 4,5,6,7,8; 4,5,6,7,8 can be implemented in parallel after 3; 8 depends on 7’s state shape and callback_data convention.
