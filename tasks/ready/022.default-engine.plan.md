# 022 — Interactive Engine Auto-Detection: Development Plan

## Phase 1: Dependencies

### Step 1.1 — Add `@inquirer/prompts`

Install `@inquirer/prompts` as a runtime dependency. This provides `confirm` (y/n) and `select` (interactive list with arrow keys + number keys). It's the modern, tree-shakeable successor to Inquirer.js and works well with ESM + Node 18+.

```bash
pnpm add @inquirer/prompts
```

### Step 1.2 — Add `open` package

Install `open` for cross-platform browser opening (macOS, Linux, Windows). Used in the "no engines found" install-guidance path.

```bash
pnpm add open
```

---

## Phase 2: Engine probe capability

### Step 2.1 — Add `probe()` to `EngineAdapter` interface

In `src/engine/types.ts`, add to the `EngineAdapter` interface:

```typescript
probe(cwd: string, timeoutMs?: number): Promise<boolean>
```

- Runs a minimal "hi" prompt through the engine CLI
- Returns `true` if the engine produces a response (exit code 0 + non-empty stdout)
- Respects a timeout (default: 30s) — kills the process if exceeded
- Does **not** require a `ProjectContext` — only needs `cwd` for engines that require it
- Does **not** do session management, context building, or output parsing

### Step 2.2 — Implement `probe()` in each adapter

Each adapter already knows its CLI invocation. Implement a minimal version:

| Engine   | Probe command |
|----------|--------------|
| claude   | `claude -p "hi" --output-format stream-json` |
| opencode | `opencode run "hi"` |
| copilot  | `copilot -p "hi" --allow-all` |
| cursor   | `agent --print --workspace <cwd> --trust --force "hi"` |
| codex    | `codex exec -C <cwd> --full-auto --skip-git-repo-check "hi"` |

Implementation pattern (shared across all adapters):
- Spawn the CLI with `stdio: ["ignore", "pipe", "pipe"]`
- Collect stdout
- Set a `setTimeout` that kills the child process on timeout
- Resolve `true` if exit code === 0 and stdout is non-empty
- Resolve `false` on error, non-zero exit, or timeout

Consider extracting a shared helper `spawnProbe(cmd, args, cwd, timeoutMs)` in a utility file (e.g., `src/engine/probe-utils.ts`) to avoid duplicating the spawn+timeout logic across 5 adapters.

---

## Phase 3: Detection module

### Step 3.1 — Create `src/engine/detect.ts`

This module contains the full interactive detection flow. It exports a single entry point:

```typescript
export async function detectEngine(
  configDir: string,
  logger: pino.Logger,
): Promise<{ engine: EngineName; persist: boolean }>
```

Returns the chosen engine name and whether the user wants it persisted to config.

### Step 3.2 — Implement missing-engine check helper

Create a helper function (can live in `detect.ts` or `config.ts`) that inspects the raw loaded config:

```typescript
export function isEngineConfigured(config: MultiConfigFile): boolean
```

Returns `true` if `globals.engine?.name` is set **or** every project has `engine?.name` set. Returns `false` if any project would fall through to the hardcoded `"claude"` default.

Note: The simplest heuristic is to check `globals.engine?.name` only — if globals has it, all projects inherit it. If globals doesn't have it, we trigger detection (even if some projects have it explicitly set, since the user should have a global default).

### Step 3.3 — Implement detection with self-replacing progress

The detection function iterates over engines in priority order: `["opencode", "claude", "copilot", "cursor", "codex"]`.

For each engine:
1. Create the adapter via `getEngine(name)`
2. Overwrite the current terminal line with: `Checking <name>...` (use `process.stdout.write("\r\x1b[K...")`)
3. Try `adapter.check()` — if it throws, mark as unavailable, log at debug, update line to `Checking <name>... ✗ not found`, continue
4. If `check()` passes, run `adapter.probe(configDir)` — if it returns false, mark as unavailable, log at debug, update line to `Checking <name>... ✗ check failed`, continue
5. If both pass, mark as available, log at debug, update line to `Checking <name>... ✓ available`
6. Brief pause (~500ms) before overwriting with the next engine so the user can see the result

After all engines are tested, clear the progress line with `\r\x1b[K`.

### Step 3.4 — Implement interactive prompts

**Step 1 — Initial y/n:**
Use `@inquirer/confirm` for the "do you want me to check your system" prompt.

**Step 3a — Engine selection (engines found):**
Use `@inquirer/select` with the list of available engines. The `select` prompt supports arrow keys and type-to-filter out of the box. For number-key jumping, we can prefix each choice label with its index (e.g., `1. opencode`, `2. claude`).

**Step 3b — Install guidance (no engines found):**
Same `@inquirer/select` with all 5 engines. After selection, call `open(url)` to open the browser, then `process.exit(0)`.

**Step 4 — Persist y/n:**
Use `@inquirer/confirm` for the "add to your configuration file?" prompt.

### Step 3.5 — Implement config file writer

Create a function to write the engine name into `hal.config.json`:

```typescript
async function persistEngineToConfig(configDir: string, engine: EngineName): Promise<void>
```

- Read `hal.config.json` as a string
- Parse to object
- Set `obj.globals.engine = { ...obj.globals?.engine, name: engine }` (preserve any existing engine sub-fields like `session`, `model`)
- Ensure `obj.globals` exists (create if needed)
- Write back with `JSON.stringify(obj, null, 2) + "\n"`

### Step 3.6 — Define install URLs

Store as a constant map in `detect.ts`:

```typescript
const INSTALL_URLS: Record<EngineName, string> = {
  opencode: "https://opencode.ai",
  claude: "https://docs.anthropic.com/en/docs/claude-code/overview",
  copilot: "https://docs.github.com/en/copilot/github-copilot-in-the-cli",
  cursor: "https://docs.cursor.com/agent",
  codex: "https://github.com/openai/codex",
};
```

Verify URLs are current at implementation time.

---

## Phase 4: Boot integration

### Step 4.1 — Modify `runStart()` in `src/cli.ts`

After `loadMultiConfig(configDir)` and before `runBotsForConfig()`, insert the detection gate:

```
const loaded = loadMultiConfig(configDir);

if (!isEngineConfigured(loaded.config)) {
  const { engine, persist } = await detectEngine(configDir, startupLogger);

  if (persist) {
    await persistEngineToConfig(configDir, engine);
    // Re-load config so the written value is picked up cleanly
    loaded = loadMultiConfig(configDir);
  } else {
    // Patch in-memory: set globals.engine.name so resolveProjectConfig picks it up
    loaded.config.globals = loaded.config.globals ?? {};
    loaded.config.globals.engine = { ...loaded.config.globals.engine, name: engine };
  }
}

const handles = await runBotsForConfig(configDir, loaded, startupLogger);
```

Note: `loaded` must be declared with `let` instead of `const` to support re-assignment on the persist path.

### Step 4.2 — Remove hardcoded `"claude"` default

In `src/config.ts` line 340-342, the fallback is currently:

```typescript
engine: (project.engine?.name ?? globals.engine?.name ?? "claude") as EngineName
```

After this task, if detection has run, `globals.engine.name` will always be set (either persisted or in-memory). The `"claude"` fallback is still a safe last resort but will effectively never be reached when the interactive flow is active.

Leave the fallback in place as a safety net for non-TTY environments or programmatic usage.

---

## Phase 5: Edge cases and polish

### Step 5.1 — Non-TTY guard

If `process.stdin.isTTY` is falsy (e.g., piped input, Docker without `-it`), skip the interactive flow entirely. Fall back to the existing `"claude"` default with a warning log:

```
startupLogger.warn("No engine configured and stdin is not a TTY — falling back to 'claude'. Set globals.engine.name in hal.config.json.");
```

### Step 5.2 — Biome compliance

Run `pnpm run lint:fix` after all changes. Ensure the new module follows the project's existing patterns (named exports, no default exports, proper import extensions `.js`).

### Step 5.3 — TypeScript build verification

Run `pnpm run build` to ensure clean compilation with no type errors.

---

## File change summary

| File | Action |
|------|--------|
| `package.json` | Add `@inquirer/prompts`, `open` dependencies |
| `src/engine/types.ts` | Add `probe()` to `EngineAdapter` interface |
| `src/engine/probe-utils.ts` | **New** — shared spawn+timeout helper for probe |
| `src/engine/adapters/claude.ts` | Implement `probe()` |
| `src/engine/adapters/opencode.ts` | Implement `probe()` |
| `src/engine/adapters/copilot.ts` | Implement `probe()` |
| `src/engine/adapters/cursor.ts` | Implement `probe()` |
| `src/engine/adapters/codex.ts` | Implement `probe()` |
| `src/engine/detect.ts` | **New** — detection flow, prompts, config writer, install URLs |
| `src/engine/index.ts` | Export `detectEngine`, `isEngineConfigured` |
| `src/cli.ts` | Insert detection gate in `runStart()` |
