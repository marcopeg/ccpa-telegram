# Plan: Config hot-reload

## Overview

When any hal config file in the config directory changes (`hal.config.json`, `hal.config.local.json`, `.env`, `.env.local`), stop all running bots gracefully, reload configuration, and start bots again for the (possibly changed) set of projects. The process keeps running; the config watcher is always on. Project-level files (per-project `.env`, commands, skills, hooks) are out of scope and use existing reload mechanisms.

## Affected Files

| File | Change |
|------|--------|
| `src/config.ts` | Add `tryLoadMultiConfig()` that throws instead of `process.exit(1)`; refactor `loadMultiConfig` to use shared logic |
| `src/cli.ts` | Extract `runBotsForConfig()`; add config watcher + reload loop; wire shutdown to close watcher |
| `src/config-watcher.ts` | **New** — chokidar-based watcher for the four config files, debounced callback |

---

## Phase 1 — Config load without process.exit

**Goal:** Allow the reload path to attempt loading config and handle failure (log, retry on next change) instead of exiting the process.

**Step 1.1** — Extract the core loading logic in `src/config.ts` into an internal function that throws on any error (e.g. `loadMultiConfigInternal(configDir): LoadedConfigResult`). Replace every `console.error(...); process.exit(1)` with `throw new Error(...)` (or a custom `ConfigLoadError` with a message that includes the same user-facing text). Keep the same validation and merge steps.

**Step 1.2** — Implement the existing public API in terms of the internal function:
- `loadMultiConfig(configDir)`: call internal function in try/catch; on catch, log the error message (e.g. to console.error) and call `process.exit(1)`. Used at first startup so behavior is unchanged.
- Add and export `tryLoadMultiConfig(configDir): LoadedConfigResult`: call the internal function (no catch/exit). Used by the hot-reload callback so reload failures can be caught and logged without exiting.

**Step 1.3** — Ensure `loadLocalConfig` and any other helpers that currently exit are only used from the internal path; if they call exit, refactor them to throw so the internal function is exit-free.

---

## Phase 2 — Extract “run bots for config”

**Goal:** Reuse the same “load → resolve → start bots” flow for both initial start and reload, without duplicating logic.

**Step 2.1** — In `src/cli.ts`, extract a function that, given an already-loaded multi-config, resolves projects, builds contexts, and starts all bots:

- Signature: `runBotsForConfig(configDir: string, multiConfig: MultiConfigFile, startupLogger: pino.Logger): Promise<BotHandle[]>` (import/use the appropriate types: `LoadedConfigResult` or the raw config type from config.ts).
- Move from current `runStart()` into `runBotsForConfig()`: resolving projects (with inactive filter), `validateProjects`, building `ProjectContext[]` (evaluate boot-time shells, getEngine, etc.), emitting flow=false notices, and `Promise.all(contexts.map(startBot))`.
- On “any bot fails to start”, reject (so caller can handle; initial run will still exit, reload will log).

**Step 2.2** — Add a helper that performs “load config + run bots” for the **initial** run (must exit on load error). For example: `runStart()` first calls `loadMultiConfig(configDir)` (exits on error), then `runBotsForConfig(configDir, multiConfig, startupLogger)`, then proceeds to watcher + signals. No change to first-run behavior.

**Step 2.3** — (Optional) If useful for clarity, introduce a small type for “startup logger” or pass it through so reload and initial run share the same logging.

---

## Phase 3 — Config watcher module

**Goal:** Watch only the four hal config files in the config directory and invoke a debounced callback on change.

**Step 3.1** — Create `src/config-watcher.ts`.

**Step 3.2** — Implement a function, e.g. `startConfigWatcher(configDir: string, onConfigChange: () => void | Promise<void>): ConfigWatcherHandle`:

- **Watched paths:** exactly four paths under `configDir`: `hal.config.json`, `hal.config.local.json`, `.env`, `.env.local`. Use `path.join(configDir, ...)` so paths are absolute. Do not watch per-project cwds.
- **Library:** use `chokidar` (already a dependency). Watch the four files explicitly (chokidar supports watching a list of files).
- **Events:** react to `add`, `change`, `unlink` (so creating a missing file or deleting one triggers reload).
- **Debounce:** use a single timer (e.g. 300–500 ms). On any event, clear the previous timer and set a new one; when the timer fires, call `onConfigChange()` once. If `onConfigChange` is async, the caller is responsible for awaiting it; the watcher does not need to await.
- **Return value:** an object with `stop(): Promise<void>` that closes the chokidar watcher and clears any pending debounce timer. Export the type (e.g. `ConfigWatcherHandle`).

**Step 3.3** — Use `ignoreInitial: true` so the initial scan does not trigger `onConfigChange`.

---

## Phase 4 — Wire reload loop and shutdown in CLI

**Goal:** After the first successful start, start the config watcher. On debounced config change, stop all bots, reload config (without exiting), and start bots again. On SIGINT/SIGTERM, stop the watcher and all bots, then exit.

**Step 4.1** — In `runStart(configDir)` after the first `runBotsForConfig()` succeeds and you have `handles`:

- Call `startConfigWatcher(configDir, onConfigChange)` and store the returned handle (e.g. `configWatcher`).
- Implement `onConfigChange` as an async function that:
  1. Log: “Config change detected” (use startupLogger).
  2. Await `Promise.all(handles.map((h) => h.stop()))`; then log “All bots stopped”.
  3. Try: call `tryLoadMultiConfig(configDir)`; on success, call `runBotsForConfig(configDir, result.config, startupLogger)` and assign the returned array to `handles` (so the next reload and shutdown use the new handles). Log “Bots started” with count and optionally slugs.
  4. Catch: log the error (reload failed); leave `handles` as-is (empty if this was first reload after a bad config). Do not exit the process; the user can fix the config and save again to trigger another reload.

**Step 4.2** — Guard against concurrent reloads: if `onConfigChange` is still running (e.g. bots still stopping or starting), ignore a new debounced invocation (e.g. set a “reloading” flag at the start of the callback and clear it in a finally block; if the flag is set when the debounced callback fires, return early). This avoids overlapping stop/start cycles.

**Step 4.3** — Shutdown (SIGINT/SIGTERM): in the existing shutdown handler, before or after stopping bots, call `await configWatcher.stop()` so the chokidar watcher is closed. Then `process.exit(0)` as today.

**Step 4.4** — Ensure the startup logger is available in the reload path (e.g. create it once in `runStart` and pass it into `runBotsForConfig` and use it in `onConfigChange` for all reload-related logs).

---

## Phase 5 — Graceful stop and logging

**Goal:** Confirm that in-flight requests complete before bots shut down, and that all required log points are present.

**Step 5.1** — Verify `BotHandle.stop()` behavior: it calls `bot.stop()` then awaits the bot’s run promise. Check Grammy’s documentation or code: does `bot.stop()` stop polling and allow in-flight updates to finish? If yes, document in code or plan that graceful behavior is satisfied. If no, extend `BotHandle.stop()` (e.g. track in-flight work and await it) so that in-flight requests complete before the handle’s promise resolves.

**Step 5.2** — Confirm logging:
- “Config change detected” when the debounced callback runs.
- “All bots stopped” after stopping handles.
- “Reload failed” (or equivalent) with error message when `tryLoadMultiConfig` or `runBotsForConfig` throws.
- “Bots started” (or “All bots running”) with count and optionally project slugs after a successful reload.

---

## Phase 6 — Testing and edge cases

**Step 6.1** — Manual test: start the app, edit `hal.config.json` (e.g. change a project name or add a project), save; expect bots to stop and new set to start, with logs as above.

**Step 6.2** — Manual test: introduce an invalid config (e.g. invalid JSON or schema), save; expect “reload failed” log, no crash, and no bots running until config is fixed and saved again.

**Step 6.3** — Manual test: SIGINT during normal run and during reload; expect watcher and bots to stop and process to exit.

**Step 6.4** — Optional: add a simple test or script that touches the four config files and asserts the watcher fires (if the project has tests for the CLI).

---

## Summary

| Phase | Description |
|-------|-------------|
| 1 | Config load without process.exit: internal throw-based loader + `tryLoadMultiConfig` |
| 2 | Extract `runBotsForConfig()` from `runStart()` |
| 3 | New `config-watcher.ts`: chokidar, four files, debounce, `stop()` |
| 4 | CLI: start watcher after first run; reload callback (stop → try load → run bots); shutdown closes watcher; re-entrancy guard |
| 5 | Verify graceful stop; ensure all required logs |
| 6 | Manual (and optional automated) testing |

Dependencies: Phase 1 first (reload needs tryLoadMultiConfig). Phase 2 can be done in parallel or right after. Phase 3 is independent. Phase 4 depends on 1, 2, 3. Phase 5 and 6 after 4.
