# Plan: Project-Specific Slash Commands

## Overview

Implement project-specific slash commands with auto-registration in Telegram's UI and full hot-reload support. Commands are `.mjs` files loaded from disk, and the bot re-publishes its command list to Telegram automatically whenever files are added, changed, or removed — enabling the self-extension loop where Claude can write new command files and users see them immediately.

## Affected Files

| File | Change |
|------|--------|
| `package.json` | Add `chokidar` dependency |
| `src/bot/commands/loader.ts` | **New** — command file scanning, importing, merging |
| `src/bot/commands/watcher.ts` | **New** — file watcher + debounced re-publish |
| `src/bot/handlers/text.ts` | Intercept `/command` messages before Claude |
| `src/bot.ts` | Wire startup registration and watcher; extend `BotHandle.stop()` |

---

## Phase 1 — Add `chokidar` Dependency

**Step 1.1** — Install `chokidar`:
```bash
pnpm add chokidar
```

`chokidar` provides reliable cross-platform filesystem watching with `add`/`change`/`unlink` events. Node's native `fs.watch` is not used because it has known reliability issues on macOS.

---

## Phase 2 — Command Loader (`src/bot/commands/loader.ts`)

Create a module responsible for scanning, importing, and merging command files.

### Exports

```ts
export interface CommandEntry {
  command: string;       // name without leading slash (e.g. "deploy")
  description: string;  // from file's `description` export
  filePath: string;      // absolute path to the .mjs file
}

// Scan both dirs, import all .mjs files, return merged list.
// Project-specific takes precedence over global on name collision.
export async function loadCommands(
  projectCwd: string,
  configDir: string,
  logger: pino.Logger,
): Promise<CommandEntry[]>

// Resolve the file path for a single command name.
// Returns null if not found in either directory.
export function resolveCommandPath(
  commandName: string,
  projectCwd: string,
  configDir: string,
): string | null
```

### Implementation Notes

- Project dir: `<projectCwd>/.ccpa/commands/`
- Global dir: `<configDir>/.ccpa/commands/`
- Both directories are optional — missing dirs are silently skipped
- **Every import MUST use cache-busting**: `import(\`${filePath}?t=${Date.now()}\`)`
  - This is non-negotiable. Without it, Node's ESM cache returns stale modules silently.
- If a file is missing `description`, log a warning and skip it (don't crash)
- If a file throws on import, log the error and skip it (don't crash)
- Merge: build a `Map<string, CommandEntry>` keyed by command name; populate globals first, then overwrite with project-specific entries

---

## Phase 3 — Command Watcher (`src/bot/commands/watcher.ts`)

Create a module that watches both command directories and re-publishes to Telegram on any change.

### Exports

```ts
export interface CommandWatcher {
  stop: () => Promise<void>;
}

export function startCommandWatcher(
  bot: Bot,
  projectCwd: string,
  configDir: string,
  logger: pino.Logger,
): CommandWatcher
```

### Implementation Notes

- Watch `<projectCwd>/.ccpa/commands/*.mjs` and `<configDir>/.ccpa/commands/*.mjs`
- Use `chokidar.watch([projectCommandDir, globalCommandDir], { ignoreInitial: true })`
  - `ignoreInitial: true` — skip events for existing files on startup (initial registration is done separately)
  - Watch directories, not files directly, so `add` events fire when new files are created
- React to: `add`, `change`, `unlink` on `*.mjs` files
- **Debounce**: collect events for 300ms before acting, to handle cases where multiple files are written in rapid succession (e.g. Claude writing several files at once)
- On trigger: call `loadCommands()` → call `bot.api.setMyCommands()`
- `setMyCommands` is idempotent — always publish the full merged list, not a delta
- Log the updated command list after each re-publish at `info` level
- The `stop()` method closes the chokidar watcher

---

## Phase 4 — Runtime Command Dispatch (`src/bot/handlers/text.ts`)

Intercept messages starting with `/` before they reach Claude.

### Change

At the top of the text handler, before the Claude execution block, add:

```
if message starts with "/":
  parse commandName = first token after "/" (stop at space or @)
  parse args = remaining tokens
  filePath = resolveCommandPath(commandName, config.cwd, config.configDir)

  if filePath found:
    import(filePath + "?t=" + Date.now())   ← cache-bust every time
    call mod.default({ args, ctx: gramCtx, projectCtx: ctx })
    if return value is non-null string: sendChunkedResponse
    return   ← do NOT fall through to Claude

  // no file found → fall through to Claude as-is
```

### Notes

- Parse only the command name: `/deploy staging` → name=`deploy`, args=`['staging']`
  - Strip bot username suffix if present: `/deploy@mybot` → `deploy`
- **Cache-bust on every dispatch call** — not just on watcher events. The file may have been updated between messages and the watcher debounce may not have fired yet.
- Errors from command execution: catch, reply with `Command failed: <error.message>`, log full stack. Do not crash the handler.
- Returning `null` or `undefined` from the command handler suppresses the reply (command handles its own response).

---

## Phase 5 — Wire into `startBot` (`src/bot.ts`)

### Changes

1. **Startup registration** — after `await startedPromise`, before returning the handle:
   ```ts
   const commands = await loadCommands(config.cwd, config.configDir, logger);
   if (commands.length > 0) {
     await bot.api.setMyCommands(commands.map(c => ({ command: c.command, description: c.description })));
     logger.info({ count: commands.length }, 'Commands registered with Telegram');
   }
   ```

2. **Start watcher** — immediately after startup registration:
   ```ts
   const watcher = startCommandWatcher(bot, config.cwd, config.configDir, logger);
   ```

3. **Extend `stop()`** — include watcher cleanup:
   ```ts
   stop: async () => {
     await watcher.stop();
     rateLimitCleanup();
     await bot.stop();
     await runningPromise;
   }
   ```

---

## Phase 6 — Example Command File

Add `examples/obsidian/.ccpa/commands/status.mjs` as a reference implementation to document the API:

```js
export const description = 'Show project status';
export const usage = '/status';

export default async function({ args, ctx, projectCtx }) {
  const { config } = projectCtx;
  return `Project: ${config.name ?? config.slug}\nDirectory: ${config.cwd}`;
}
```

---

## Self-Extension Loop (Verification Checklist)

The end-to-end goal is that Claude can write a new command file and the user sees it in Telegram with no restart. This requires all of the following to work together:

- [ ] Watcher is running and watching both directories after bot start
- [ ] Watcher reacts to `add` events (new files), not just `change`
- [ ] Debounce fires after Claude finishes writing (300ms is sufficient)
- [ ] `loadCommands` re-imports with cache-busting (`?t=Date.now()`)
- [ ] `bot.api.setMyCommands` is called with the full updated list
- [ ] Telegram clients receive the updated command list (usually within seconds)

## Dependency Graph

```
Phase 1 (chokidar)
  └─ Phase 2 (loader)
       └─ Phase 3 (watcher)  ──┐
       └─ Phase 4 (dispatch) ──┤
                                └─ Phase 5 (bot.ts wiring)
                                     └─ Phase 6 (example)
```

Phases 3 and 4 can be developed in parallel once Phase 2 is complete.
