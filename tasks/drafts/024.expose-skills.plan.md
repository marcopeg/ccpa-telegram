# Plan: 024 — Expose skills across engines

## Phase 1 — Discovery and engine research

### Step 1.1: Inventory current behavior
- Trace current skill/command discovery and where it is consumed (`/help`, Telegram command sync).
- Identify engine-specific assumptions currently embedded outside adapters.

### Step 1.2: Research official engine docs
- Collect authoritative documentation for supported engines (Codex, Claude, Copilot, Cursor, OpenCode, and others present in repo).
- Extract how each engine expects project skills/commands to be structured and discovered.
- Record confidence level per source (official docs vs inferred behavior).

### Step 1.3: Define normalized model
- Produce a small normalized contract for skill discovery output used by UI/help + Telegram layers.
- Define per-engine default locations and precedence (including `.agents/skills/**/SKILL.md` baseline).

---

## Phase 2 — Engine-level implementation

### Step 2.1: Move discovery ownership to adapters
- Implement/refactor adapter-facing logic so each engine can return or resolve its skill sources.
- Keep shared utilities only for generic parsing/watching behavior.

### Step 2.2: Add monitoring/watcher integration
- Ensure relevant file changes are watched and trigger refresh/update paths.
- Keep reload behavior aligned with existing config-watcher patterns.

### Step 2.3: Connect to output channels
- Feed normalized skill data into `/help` placeholder output.
- Feed skill-derived commands into Telegram command publishing flow.

---

## Phase 3 — Documentation and validation

### Step 3.1: Update README
- Document engine-specific skill discovery rules.
- Clarify where `.agents/skills/**/SKILL.md` is used and where engine-specific alternatives apply.
- Document known platform constraints and fallback behavior.

### Step 3.2: Verification
- Validate build/lint.
- Manually verify at least one representative engine path in `/help` and Telegram sync behavior.
- Confirm no regressions for existing command groups/order.
