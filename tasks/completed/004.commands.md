# Task: Project-Specific Slash Commands

Expose project-specific slash commands in the Telegram UI by hooking into the Telegram Bot API and loading command implementations from `.mjs` files on disk.

## Answer

Yes — Telegram's Bot API supports `setMyCommands`, which populates the `/` suggestion menu in the Telegram UI. Commands can be scoped per-bot, so each project bot can have its own command list.

## Command File Format

Commands are `.mjs` files that export a default handler and metadata:

```js
// .ccpa/commands/deploy.mjs
export const description = 'Deploy the project';

export default async function({ args, ctx, projectCtx }) {
  const env = args[0] ?? 'staging';
  return `Deploying to ${env}...`;
}
```

- `description` (required) — shown in Telegram's `/` suggestion menu
- `default` export — async handler function
  - `args`: string[] — tokenized arguments after the command name (e.g. `/deploy staging` → `['staging']`)
  - `ctx`: `Record<string, string>` — resolved context sent to the AI (all `bot.*`, `sys.*`, `project.*`, config vars, and hook results)
  - `gram`: Grammy `Context` — raw Telegram message context (advanced use only)
  - `projectCtx`: `ProjectContext` — full project context including Claude executor, config, logger, user paths

The handler return value is sent back to the user as a message. Returning `null` or `undefined` suppresses the reply.

## Command Resolution

When a message starts with `/`, resolve the command in this order:

1. **Project-specific**: `<project.cwd>/.ccpa/commands/<command>.mjs`
2. **Global fallback**: `<configDir>/.ccpa/commands/<command>.mjs` (directory containing `ccpa.config.json`)
3. **No match**: pass the message through to Claude as-is (so skills can handle it)

Where `<command>` is the command name without the leading `/` (e.g. `/deploy` → `deploy`).

## Startup: Auto-Registration with Telegram

On bot startup, after loading each project:

1. Scan both the project-specific and global command directories for `.mjs` files
2. Import each file and read its `description` export
3. Merge the lists (project-specific takes precedence over global for the same name)
4. Call `bot.api.setMyCommands(commands)` to register them with Telegram

This populates the `/` suggestion menu in the Telegram UI for each project's bot.

## Hot-Reload: Live Command Updates

**This is a first-class requirement, not an afterthought.** The goal is that a bot can expand its own command set from within a conversation — for example, Claude could write a new `.mjs` file as part of a task — and the user immediately sees the updated `/` menu in Telegram without any restart.

### File Watching

Watch both command directories for filesystem changes using `chokidar` (preferred) or Node's `fs.watch`. React to `add`, `change`, and `unlink` events on `*.mjs` files.

On any change:
1. Re-scan both directories
2. Re-import all files with cache-busting (see below)
3. Re-merge the command list
4. Re-call `bot.api.setMyCommands(commands)`

This is the same pattern already used for context hooks in [src/context/resolver.ts](src/context/resolver.ts) — follow that precedent.

### ES Module Cache-Busting (Critical)

Node.js caches ES module imports permanently by URL. A plain `import('./deploy.mjs')` called twice always returns the first result, even if the file changed on disk. **This will silently serve stale command logic.**

To force a fresh import on every load, append a timestamp query parameter:

```ts
const mod = await import(`${filePath}?t=${Date.now()}`);
```

This must be applied **every time** a command file is imported — both at startup and during hot-reload. Never import command files without cache-busting.

### Re-publishing to Telegram

`setMyCommands` is idempotent — calling it repeatedly with the same list is harmless. After any filesystem change, always re-publish the full merged list, not just the delta. Debounce rapid successive changes (e.g. 300ms) to avoid flooding the Telegram API when multiple files are written at once.

### The Full Self-Extension Loop

The intended outcome is:

1. User asks the bot to create a new command (e.g. "create a /standup command that summarises today's git log")
2. Claude writes `.ccpa/commands/standup.mjs` to disk
3. The file watcher detects the new file
4. The bot re-imports it, re-merges the command list, and calls `setMyCommands`
5. The user's Telegram client shows `/standup` in the `/` menu — automatically, with no restart

This loop must work end-to-end. The watcher, cache-busting, and re-publish must all be in place for it to function.

## Runtime: Command Dispatch

Add a pre-handler check in the text message handler (before passing to Claude):

1. Parse the command name and args from the message text
2. Resolve the matching `.mjs` file path (project-specific first, then global)
3. Import with cache-busting: `import(\`${filePath}?t=${Date.now()}\`)`
4. Call the default export with `{ args, ctx, projectCtx }`
5. Send the return value as a reply
6. On error, send a user-facing error message and log the full error

**Note:** Runtime dispatch must also use cache-busting so that if a command file was updated since startup, the latest version is always executed.

## Error Handling

- If the `.mjs` file fails to import or throws during execution, reply with a generic error message (e.g. `Command failed: <error.message>`) and log the full stack trace.
- Missing `description` export should log a warning at startup but not crash the bot.

## File Locations Summary

```
<project.cwd>/.ccpa/commands/     ← project-specific commands
<configDir>/.ccpa/commands/       ← global commands (fallback)
```
