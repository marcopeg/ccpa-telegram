# Plan: Custom `/start` message

Task: [017.custom-start-message.md](./017.custom-start-message.md)

---

## Phase 1 — Config schema and validation ✅

Add `start` to the Zod schemas, `ResolvedProjectConfig`, and boot-time validation.

### Step 1.1 — Define `StartConfigSchema` in `src/config.ts`

Add a new Zod schema after the existing `EngineConfigSchema`:

```ts
const StartMessageSchema = z
  .object({
    text: z.string().optional(),
    from: z.string().optional(),
  })
  .refine((m) => !!m.text !== !!m.from, {
    message: "start.message must have exactly one of 'text' or 'from'",
  });

const StartConfigSchema = z
  .object({
    session: z.object({ reset: z.boolean() }).partial().optional(),
    message: StartMessageSchema,
  })
  .optional();
```

The `.refine()` ensures Zod rejects configs where both or neither are set.

### Step 1.2 — Add `start` to `ProjectFileSchema`

Insert `start: StartConfigSchema` into `ProjectFileSchema` (alongside `context`, `dataDir`, etc.).

### Step 1.3 — Add `start` to `LocalProjectSchema`

`LocalProjectSchema` derives from `ProjectFileSchema.partial()`, so `start` will automatically be available as an optional override in `hal.config.local.json`.

### Step 1.4 — Add resolved `start` to `ResolvedProjectConfig`

Add a new optional field to the interface:

```ts
start?: {
  sessionReset: boolean;
  message: string;           // resolved text (inline or read from file)
};
```

The message content is resolved eagerly at boot (not lazily at `/start` time) because:
- `from` file existence must be validated at boot.
- The raw template string (with `${}`, `@{}`, `#{}` placeholders) is stored; substitution happens at message-send time.

### Step 1.5 — Resolve `start` in `resolveProjectConfig()`

After the existing field resolution, add:

```ts
// Resolve start config
let startConfig: ResolvedProjectConfig["start"] = undefined;
if (project.start) {
  const msg = project.start.message;
  let messageTemplate: string;
  if (msg.from) {
    const filePath = resolve(resolvedCwd, msg.from);
    if (!existsSync(filePath)) {
      console.error(
        `Configuration error: start.message.from file not found: ${filePath}`,
      );
      process.exit(1);
    }
    try {
      messageTemplate = readFileSync(filePath, "utf-8");
    } catch (err) {
      console.error(
        `Configuration error: cannot read start.message.from file: ${filePath} — ${err instanceof Error ? err.message : String(err)}`,
      );
      process.exit(1);
    }
  } else {
    messageTemplate = msg.text!;
  }
  startConfig = {
    sessionReset: project.start.session?.reset ?? false,
    message: messageTemplate,
  };
}
```

Then include `start: startConfig` in the returned object.

### Step 1.6 — Verify `substituteEnvVars` skips `start.message`

`start.message.text` and `start.message.from` may contain `${}` placeholders intended for the context resolver (message-time), not for env-var substitution (boot-time). The existing `substituteEnvVars` function skips keys named `"context"`; **add `"start"` to the skip list** so its `${}` patterns are preserved for runtime resolution.

**Files changed:** `src/config.ts`

---

## Phase 2 — Rewrite the `/start` handler ✅

Convert `startHandler` from a plain function to a `createStartHandler(projectCtx)` factory, matching the existing pattern.

### Step 2.1 — Rewrite `src/bot/commands/start.ts`

Replace the module with a factory:

```ts
import { join } from "node:path";
import type { Context } from "grammy";
import type { ProjectContext } from "../../types.js";
import { clearSessionData } from "../../user/setup.js";
import { createAgent } from "../../agent/index.js";
import { resolveContext } from "../../context/resolver.js";

const DEFAULT_MESSAGE = (name: string) =>
  `Hello ${name}! I'm your personal assistant.\n\n` +
  `You can:\n` +
  `- Send any message to chat with me\n` +
  `- Send images or documents for analysis\n` +
  `- Use /clear to start a new conversation\n\n` +
  `Type /help for more information.`;

export function createStartHandler(ctx: ProjectContext) {
  return async (gramCtx: Context): Promise<void> => {
    // ...implementation (see steps 2.2–2.4)
  };
}
```

### Step 2.2 — Default behavior (no `start` config)

When `ctx.config.start` is `undefined`, send the current hardcoded welcome message (plain text, no `parse_mode`). This preserves backward compatibility.

### Step 2.3 — Session reset

When `ctx.config.start.sessionReset` is `true`:

1. Get `userId` from `gramCtx.from?.id`.
2. Call `clearSessionData(userDir)` (same as `/new`).
3. For active-reset engines (copilot, codex): call `createAgent(ctx).call(config.engineSessionMsg, { continueSession: false })`.
4. Log the reset.

This logic mirrors `createSessionHandler` in `src/bot/commands/session.ts`. Extract common reset logic into a shared helper if it reduces duplication (see Phase 3).

### Step 2.4 — Send custom welcome message with substitution

1. Build the context vars by calling `resolveContext()` with the Grammy context (same as the text handler does).
2. Apply `${}` and `@{}` substitution to the stored `ctx.config.start.message` template.
3. Reply with `parse_mode: "Markdown"`.

The existing `resolveContext()` builds `bot.*`, `sys.*`, `project.*` and runs `${}` + `@{}` substitution on context values. For the start message, we need a lighter helper that just substitutes placeholders in a single string using the resolved context map. Extract or reuse the `resolveAppVars` and `evaluateMessageTimeShells` private functions from `src/context/resolver.ts` (see Phase 3).

**Files changed:** `src/bot/commands/start.ts`

---

## Phase 3 — Extract shared helpers ✅

### Step 3.1 — Extract session-reset logic

Both `createSessionHandler` and the new `createStartHandler` need to clear session data and optionally do an active engine reset. Extract this into a shared helper in `src/bot/commands/session.ts` (or a new `src/bot/commands/utils.ts`):

```ts
export async function resetSession(
  ctx: ProjectContext,
  gramCtx: Context,
): Promise<void> { ... }
```

Update both `createSessionHandler` and `createStartHandler` to call it.

### Step 3.2 — Export a string-substitution helper from the context resolver

`resolveContext()` substitutes `${}` and `@{}` in context map values. The start handler needs to substitute these in a single arbitrary string using the resolved context map. Export a small helper from `src/context/resolver.ts`:

```ts
export function substituteMessage(
  template: string,
  vars: Record<string, string>,
  logger: pino.Logger,
): string {
  let result = resolveAppVars(template, vars);
  result = evaluateMessageTimeShells(result, logger);
  return result;
}
```

The start handler will:
1. Call `resolveContext(...)` to get the vars map.
2. Call `substituteMessage(config.start.message, vars, logger)` to get the final string.

**Files changed:** `src/context/resolver.ts`, `src/bot/commands/session.ts` (or new `src/bot/commands/utils.ts`)

---

## Phase 4 — Wire the new handler in `bot.ts` ✅

### Step 4.1 — Update import

Replace `import { startHandler }` with `import { createStartHandler }`.

### Step 4.2 — Update wiring

Replace:
```ts
bot.command("start", startHandler);
```
With:
```ts
bot.command("start", createStartHandler(projectCtx));
```

**Files changed:** `src/bot.ts`

---

## Phase 5 — Linting and build verification ✅

### Step 5.1 — Run `pnpm run lint:fix`

Ensure Biome is happy with all changed files.

### Step 5.2 — Run `pnpm run build`

Ensure TypeScript compiles without errors.

---

## Summary of files changed

| File | Changes |
|------|---------|
| `src/config.ts` | `StartConfigSchema`, `ProjectFileSchema.start`, `ResolvedProjectConfig.start`, resolve logic, `substituteEnvVars` skip |
| `src/bot/commands/start.ts` | Full rewrite → `createStartHandler(projectCtx)` factory |
| `src/context/resolver.ts` | Export `substituteMessage()` helper |
| `src/bot/commands/session.ts` | Extract shared `resetSession()` helper |
| `src/bot.ts` | Update import and wiring |
