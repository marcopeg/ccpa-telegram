## Task 006 — Multi-engine support (Copilot first)

Investigate and propose the implementation complexity for supporting multiple AI engines in HAL, starting with **GitHub Copilot via the `copilot` CLI** while keeping the architecture open for other engines.

## Goal

Enable selecting the AI engine from configuration and from `init`, without plugins, using internal code that is easy to extend.

Engine runtime set to support:
- `copilot`
- `claude`
- `codex`
- `opencode`

## Scope

### In scope (this task)

1. Assess what changes are needed to move from Claude-specific config/runtime to engine-aware behavior.
2. Define a minimal internal architecture that supports all target engines:
	- `copilot` (primary implementation target)
	- `claude`
	- `codex`
	- `opencode`
3. Define CLI/init feasibility for:
	- `npx @marcopeg/hal init --engine copilot`
	- engine-specific instructions file scaffolding.
4. Preserve existing HAL capabilities across engines, including:
	- context injection
	- custom commands
	- skills

### Out of scope (this task)

- External plugin system.

## Confirmed product decisions

1. **Copilot-first**: implement/plan GitHub Copilot now using the `copilot` CLI; architecture must stay open for additional engines.
2. **No plugins**: extensibility is done via internal code structure.
3. **Config shape**: support global default + per-project override:
	- `globals.engine`
	- optional `projects[].engine`
4. **No backward compatibility required**: project is in early development. Replace `claude.command` with `engine` + `engine.command` directly — no deprecated aliases.
5. **Default engine**: missing engine defaults to `claude`.
6. **Init behavior**: `init --engine <name>` should both:
	- set engine in generated config,
	- scaffold engine-specific instructions file.
7. **Instruction file mapping policy**:
	- prefer `AGENTS.md` whenever the target engine supports it,
	- otherwise use the engine’s documented canonical instructions file,
	- keep `CLAUDE.md` for Claude.
8. **Feature parity requirement**: all supported engines must preserve current HAL behavior for context injection, commands, and skills.

## Clarified v1 decisions (implementation defaults)

These defaults apply unless a later task explicitly changes them.

1. **Engine adapter contract**
	- Introduce a single internal adapter interface for all engines.
	- Required capabilities per adapter:
		- build prompt from HAL-enriched input (context + user content),
		- execute CLI command,
		- stream tokens/events into HAL’s existing parser shape,
		- normalize final response,
		- normalize error types (`cli_not_found`, `auth_error`, `rate_limited`, `engine_error`, `timeout`).
	- Cancellation should map to existing HAL cancellation/abort behavior.

2. **Feature parity semantics**
	- “Parity” means equivalent user-facing behavior in Telegram for context injection, commands, and skills.
	- If an engine CLI lacks a native capability, HAL must provide a compatibility layer where feasible.
	- If compatibility is not feasible, fail explicitly with a clear engine-specific limitation message (no silent degradation).

3. **Instruction file mapping (v1)**
	- `claude` -> `CLAUDE.md`
	- `copilot` -> `AGENTS.md`
	- `codex` -> `AGENTS.md`
	- `opencode` -> `AGENTS.md` (until a different canonical file is confirmed)

4. **Commands and skills compatibility**
	- Existing HAL command/skill discovery remains unchanged.
	- All engines share `.claude/skills/` as the skills directory (engine-portable; can be revisited later).
	- Engine adapters are responsible for rendering prompt wrappers/transforms needed for their CLI.
	- No engine-specific command authoring format in v1.

5. **Session behavior**
	- Claude: native session resume via `--resume <sessionId>` as today.
	- Non-Claude engines: no session resume in v1. Each message starts a fresh conversation. Document as a known limitation.
	- Session storage model and file layout remain unchanged.

6. **Failure policy for missing/broken CLI**
	- If a selected engine CLI is unavailable or unauthenticated, fail fast for that project with actionable error output.
	- No automatic fallback to another engine in v1.

## Investigation questions to answer

1. What files/modules currently assume Claude only (config schema, executor, docs, defaults, templates)?
2. What is the smallest refactor to introduce an engine abstraction without breaking current users?
3. How should command resolution work per engine (global default + project override)?
4. How should `init --engine` impact both `hal.config.json` template and project scaffolding?
5. What is required to keep/achieve feature parity (context injection, commands, skills) for each engine?
6. What is required to add/maintain additional engines after Copilot (estimated effort and touchpoints)?
7. Which adapter-level gaps remain for full parity on each engine, and are they solvable in HAL or blocked by engine CLI limitations?

## Expected output

Produce a short design note (or task comment) with:

1. **Complexity assessment** (low/medium/high) with rationale.
2. **Concrete change list** by file/module.
3. **Proposed config model** (including migration/backward compatibility behavior).
4. **Proposed init behavior** and file-mapping strategy.
5. **Implementation phases**:
	- Phase 1: introduce abstraction + Copilot
	- Phase 2: add more engines
	- Phase 3: close parity gaps and document known engine-specific limitations

## Acceptance criteria

- The plan clearly shows how engine selection can be switched via config.
- The plan clearly shows feasibility of `init --engine copilot` with appropriate instruction-file scaffolding.
- Default engine is `claude` when omitted; no backward-compatibility shims needed.
- The path to add future engines is explicit and low-friction.
- The plan explicitly describes how context injection, commands, and skills are preserved for `copilot`, `claude`, `codex`, and `opencode`.
- The design includes a single adapter contract and normalized error model used by all engines.
- `init --engine <name>` scaffolds the mapped instruction file for each supported engine in the v1 matrix above.
- Missing/invalid engine CLI fails fast with actionable diagnostics and no implicit fallback.

