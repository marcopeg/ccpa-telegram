# Plan: Multi-Project Setup (Task 001)

> Status legend: ‚¨ú pending ¬∑ üîÑ in progress ¬∑ ‚úÖ done ¬∑ ‚ùå blocked ¬∑ üìù notes

---

## Overview

The goal is to transform ccpa-telegram from a single-bot/single-CWD tool into a multi-bot/multi-folder tool driven by a restructured `ccpa.config.json`.

The core architectural shift: global singletons (`getConfig()`, `getLogger()`, `workingDirectory`) are replaced by a **per-project context object** that is created at startup for each project and threaded through all handlers, middleware, and services via closures/factory functions.

---

## Dependency Map (bottom-up refactor order)

```
config.ts        ‚Üê needs full rewrite (new schema + resolver)
logger.ts        ‚Üê needs factory (flow/persist support)
types.ts         ‚Üê NEW: ProjectContext interface
    ‚Üì
executor.ts      ‚Üê accept ProjectContext
whisper.ts       ‚Üê accept ProjectContext
fileSender.ts    ‚Üê accept ProjectContext (logger)
user/setup.ts    ‚Üê no changes (pure path utils)
telegram/chunker.ts ‚Üê no changes
    ‚Üì
middleware/auth.ts       ‚Üê factory function
middleware/rateLimit.ts  ‚Üê factory function (per-bot Map)
handlers/text.ts         ‚Üê factory or context param
handlers/photo.ts        ‚Üê factory or context param
handlers/document.ts     ‚Üê factory or context param
handlers/voice.ts        ‚Üê factory or context param
commands/clear.ts        ‚Üê factory or context param
commands/start.ts        ‚Üê no changes
commands/help.ts         ‚Üê no changes
    ‚Üì
bot.ts           ‚Üê accept ProjectContext, wire factories
    ‚Üì
cli.ts           ‚Üê load multi-config, validate, Promise.all
index.ts         ‚Üê update exports
    ‚Üì
README.md        ‚Üê full rewrite
```

---

## Phase 1 ‚Äî Config: New Schema & Resolver

**Status:** ‚¨ú pending

### What changes
`src/config.ts` is completely rewritten. The module no longer exports global singletons. Instead it exports:

1. **`loadMultiConfig(configDir: string): MultiConfig`**
   - Reads `ccpa.config.json` from `configDir`
   - Validates with `MultiConfigFileSchema` (Zod)
   - Aborts the process with a clear error if validation fails
   - Returns the raw validated config (not yet merged with globals)

2. **`resolveProjectConfig(project, globals, configDir): ResolvedProjectConfig`**
   - Merges project fields over globals over defaults
   - Resolves `cwd` (relative ‚Üí absolute from `configDir`)
   - Derives `slug` (see slug logic below)
   - Resolves `dataDir` (4 cases: default, relative, absolute, `~`)
   - Resolves `logDir` (always `<configDir>/.ccpa/<slug>/logs`)

3. **`validateProjects(projects[]): void`**
   - Ensures all `cwd` values are unique (resolved absolute paths)
   - Ensures all `botToken` values are unique
   - Ensures all `name` values are unique (if provided)
   - Exits process with descriptive error on failure

4. **`deriveSlug(name?, cwd): string`**
   - If `name` is set ‚Üí use it
   - Otherwise: strip leading `./`, replace `/` and `\` with `-`, strip leading `/`
   - Examples: `./foo/bar` ‚Üí `foo-bar`, `/abs/path/proj` ‚Üí `abs-path-proj`

5. **`resolveDataDir(dataDirRaw, projectCwd, configDir, slug): string`**
   - Empty/undefined ‚Üí `<projectCwd>/.ccpa/users`
   - `~` ‚Üí `<configDir>/.ccpa/<slug>/data`
   - Absolute path ‚Üí used as-is
   - Relative path ‚Üí `path.resolve(projectCwd, dataDirRaw)`

### New Zod schemas

```
MultiConfigFileSchema
  globals (optional)
    access.allowedUserIds
    claude.command
    logging.level / .flow / .persist
    rateLimit.max / .windowMs
    transcription.model / .showTranscription
    dataDir
  projects[]
    name (optional, string)
    cwd (required, string)
    telegram.botToken (required, string)
    access.allowedUserIds
    claude.command
    logging.level / .flow / .persist
    rateLimit.max / .windowMs
    transcription.model / .showTranscription
    dataDir
```

### New exported types

```ts
interface ResolvedProjectConfig {
  slug: string;
  cwd: string;          // resolved absolute path
  dataDir: string;      // resolved absolute path
  logDir: string;       // resolved absolute path (for persist)
  telegram: { botToken: string };
  access: { allowedUserIds: number[] };
  claude: { command: string };
  logging: { level: string; flow: boolean; persist: boolean };
  rateLimit: { max: number; windowMs: number };
  transcription: { model: string; showTranscription: boolean } | undefined;
}
```

### .env loading
Currently `.env` is loaded from the single CWD. With multi-project, each project has its own CWD. Load `.env` from each project's resolved `cwd` during `resolveProjectConfig`. Note: env vars can no longer override per-project values (they applied globally before). **Decision:** drop environment variable overrides entirely in the new format ‚Äî config file is the single source of truth.

> üìù This is a breaking change from the current env-var behavior. Document it prominently in the README.

---

## Phase 2 ‚Äî Logger: Per-Project Factory

**Status:** ‚¨ú pending

### What changes
`src/logger.ts` is rewritten. No more singleton. Exports:

1. **`createStartupLogger(): pino.Logger`**
   - Always writes to stdout, level `info`
   - Used by `cli.ts` for process-level messages (startup, project enumeration, abort errors)

2. **`createProjectLogger(config: ResolvedProjectConfig): pino.Logger`**
   - Respects `logging.level`
   - Respects `logging.flow`: if `false`, stdout stream is omitted
   - Respects `logging.persist`: if `true`, adds a file stream to `<logDir>/YYYY-MM-DD.txt`
   - Creates `logDir` directory if it doesn't exist (when persist=true)
   - Uses `pino.multistream()` to combine streams

### Pino multistream approach

```ts
const streams: pino.StreamEntry[] = [];
if (config.logging.flow) {
  streams.push({ stream: process.stdout });
}
if (config.logging.persist) {
  fs.mkdirSync(config.logDir, { recursive: true });
  const date = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
  const logFile = path.join(config.logDir, `${date}.txt`);
  streams.push({ stream: fs.createWriteStream(logFile, { flags: 'a' }) });
}
// Edge case: if both flow=false and persist=false, use a no-op stream
// so the logger doesn't throw
if (streams.length === 0) {
  streams.push({ stream: new NoopWritable() });
}
return pino({ level: config.logging.level }, pino.multistream(streams));
```

> üìù Log files use the date at process startup. No within-process daily rotation ‚Äî acceptable given typical usage patterns. Can be enhanced later.

---

## Phase 3 ‚Äî ProjectContext Type

**Status:** ‚¨ú pending

### New file: `src/types.ts`

```ts
import type pino from 'pino';
import type { ResolvedProjectConfig } from './config.js';

export interface ProjectContext {
  config: ResolvedProjectConfig;
  logger: pino.Logger;
}
```

This single object is what all bot internals receive. Keeping it minimal and extensible.

---

## Phase 4 ‚Äî Services: Accept ProjectContext

**Status:** ‚¨ú pending

### `src/claude/executor.ts`
- `executeClaudeQuery(options, ctx: ProjectContext)` ‚Äî replace `getConfig()` / `getLogger()` calls with `ctx.config` / `ctx.logger`

### `src/transcription/whisper.ts`
- `transcribeAudio(audioPath, ctx: ProjectContext)` ‚Äî replace singletons
- Note: `config.transcription` can be undefined; handle gracefully

### `src/telegram/fileSender.ts`
- `sendDownloadFiles(gramCtx, userDir, ctx: ProjectContext)` ‚Äî replace `getLogger()`

---

## Phase 5 ‚Äî Middleware: Factory Functions

**Status:** ‚¨ú pending

### `src/bot/middleware/auth.ts`

```ts
export function createAuthMiddleware(ctx: ProjectContext) {
  return async (gramCtx: Context, next: NextFunction) => {
    // uses ctx.config.access.allowedUserIds
  };
}
```

### `src/bot/middleware/rateLimit.ts`

The module-level `rateLimitStore` Map becomes a local variable inside the factory, scoped per-bot:

```ts
export function createRateLimitMiddleware(ctx: ProjectContext) {
  const store = new Map<number, RateLimitEntry>(); // per-bot store
  const cleanup = setInterval(..., 60000);
  // caller responsible for clearing interval on shutdown
  return { middleware: async (...) => {...}, cleanup: () => clearInterval(cleanup) };
}
```

> üìù Returning a cleanup function is important so that the `setInterval` is cleared on graceful shutdown, avoiding resource leaks in the multi-bot process.

---

## Phase 6 ‚Äî Handlers & Commands: Factory Pattern

**Status:** ‚¨ú pending

All handlers that currently call `getConfig()` / `getLogger()` become factory functions:

### Pattern applied to each handler

```ts
// Before
export async function textHandler(ctx: Context): Promise<void> {
  const config = getConfig();
  const logger = getLogger();
  ...
}

// After
export function createTextHandler(projectCtx: ProjectContext) {
  return async (ctx: Context): Promise<void> => {
    const { config, logger } = projectCtx;
    ...
  };
}
```

### Files affected
- `src/bot/handlers/text.ts` ‚Üí `createTextHandler(ctx)`
- `src/bot/handlers/photo.ts` ‚Üí `createPhotoHandler(ctx)`
- `src/bot/handlers/document.ts` ‚Üí `createDocumentHandler(ctx)`
- `src/bot/handlers/voice.ts` ‚Üí `createVoiceHandler(ctx)`
- `src/bot/commands/clear.ts` ‚Üí `createClearHandler(ctx)`
- `src/bot/commands/start.ts` ‚Äî no changes (no config dependency)
- `src/bot/commands/help.ts` ‚Äî no changes (no config dependency)
- `src/bot/handlers/index.ts` ‚Äî update re-exports

---

## Phase 7 ‚Äî Bot: Factory Function

**Status:** ‚¨ú pending

### `src/bot.ts`

`startBot()` becomes `startBot(projectCtx: ProjectContext): Promise<() => Promise<void>>`

Returns a shutdown function (for graceful stop).

```ts
export async function startBot(projectCtx: ProjectContext): Promise<() => Promise<void>> {
  const { config, logger } = projectCtx;

  // 1. Verify Claude CLI
  checkClaudeCommand(config.claude.command, logger);

  // 2. Create bot
  const bot = new Bot(config.telegram.botToken);

  // 3. Wire middleware (factories)
  const { middleware: rateLimitMw, cleanup: rateLimitCleanup } =
    createRateLimitMiddleware(projectCtx);
  bot.use(createAuthMiddleware(projectCtx));
  bot.use(rateLimitMw);

  // 4. Wire commands
  bot.command('start', startHandler);
  bot.command('help', helpHandler);
  bot.command('clear', createClearHandler(projectCtx));

  // 5. Wire handlers
  bot.on('message:text', createTextHandler(projectCtx));
  bot.on('message:photo', createPhotoHandler(projectCtx));
  bot.on('message:document', createDocumentHandler(projectCtx));
  bot.on('message:voice', createVoiceHandler(projectCtx));

  // 6. Error handler
  bot.catch((err) => logger.error(...));

  // 7. Start
  await bot.start({ onStart: (info) => logger.info(...) });

  // 8. Return shutdown fn
  return async () => {
    rateLimitCleanup();
    await bot.stop();
  };
}
```

---

## Phase 8 ‚Äî CLI: Multi-Bot Orchestration

**Status:** ‚¨ú pending

### `src/cli.ts` ‚Äî `runStart(cwd)`

```
1. createStartupLogger()
2. loadMultiConfig(cwd) ‚Üí { globals, projects }
3. validateProjects(projects) ‚Üí abort on error
4. For each project:
   a. resolveProjectConfig(project, globals, cwd) ‚Üí ResolvedProjectConfig
   b. Load .env from project.cwd (if exists)
5. createProjectLogger(config) for each project ‚Üí logger
6. Build ProjectContext[] array
7. For each context with flow=false:
   - startupLogger.info(`Bot "${slug}" has terminal logging suppressed.`)
   - if persist: startupLogger.info(`Persisted logs: ${logDir}`)
8. Promise.all(contexts.map(ctx => startBot(ctx)))
   - If any rejects ‚Üí log error via startupLogger ‚Üí process.exit(1)
9. Graceful shutdown: on SIGINT/SIGTERM, run all shutdown fns
```

### `src/cli.ts` ‚Äî `runInit(cwd)`

Generate new multi-project config template:
```json
{
  "globals": {
    "claude": { "command": "claude" },
    "logging": { "level": "info", "flow": true, "persist": false },
    "rateLimit": { "max": 10, "windowMs": 60000 },
    "access": { "allowedUserIds": [] }
  },
  "projects": [
    {
      "name": "my-project",
      "cwd": ".",
      "telegram": { "botToken": "YOUR_BOT_TOKEN_HERE" },
      "access": { "allowedUserIds": [] }
    }
  ]
}
```

---

## Phase 9 ‚Äî Exports: Update index.ts

**Status:** ‚¨ú pending

`src/index.ts` exports will change since the singleton exports are gone:
- Export `loadMultiConfig`, `resolveProjectConfig`, `validateProjects` from config
- Export `ProjectContext`, `ResolvedProjectConfig` types
- Export `startBot` from bot
- Remove `getConfig`, `getWorkingDirectory`, `initConfig` (no longer meaningful)

---

## Phase 10 ‚Äî README: Full Rewrite

**Status:** ‚¨ú pending

### Sections to rewrite / add

1. **Features** ‚Äî add "Multi-project support: run multiple bots from one config"
2. **How It Works** ‚Äî update for multi-project; clarify config file location vs. project CWD
3. **Quick Start** ‚Äî update commands for new config format
4. **Configuration** ‚Äî complete overhaul:
   - New config shape with `globals` + `projects`
   - `name` field explanation
   - `cwd` resolution (relative to config file)
   - `dataDir` options including `~`
   - `logging.flow` and `logging.persist`
5. **Directory Structure** ‚Äî show multi-project layout:
   ```
   workspace/
   ‚îú‚îÄ‚îÄ ccpa.config.json
   ‚îú‚îÄ‚îÄ .ccpa/
   ‚îÇ   ‚îú‚îÄ‚îÄ project-a/
   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logs/
   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 2026-02-26.txt
   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ data/       (if dataDir: "~")
   ‚îÇ   ‚îî‚îÄ‚îÄ project-b/
   ‚îÇ       ‚îî‚îÄ‚îÄ logs/
   ‚îú‚îÄ‚îÄ project-a/
   ‚îÇ   ‚îú‚îÄ‚îÄ CLAUDE.md
   ‚îÇ   ‚îî‚îÄ‚îÄ .ccpa/users/    (default dataDir)
   ‚îî‚îÄ‚îÄ project-b/
       ‚îî‚îÄ‚îÄ CLAUDE.md
   ```
6. **CLI Commands** ‚Äî update examples
7. **Environment Variables** ‚Äî note that env var overrides are removed in v2; config file is source of truth
8. **Migration Guide** ‚Äî brief section explaining the old format is no longer supported and how to migrate

---

## Implementation Notes & Risks

### Risk: Pino multistream with `flow: false`
If both `flow=false` and `persist=false`, there must be a valid sink. Use `pino.destination('/dev/null')` or a custom no-op Writable to prevent pino from throwing.

### Risk: Grammy `bot.start()` blocking behavior
Grammy's `bot.start()` returns a Promise that resolves only on shutdown. So `Promise.all([startBot(a), startBot(b)])` means both are waiting for shutdown ‚Äî this is correct behavior for a long-running process.

### Risk: Graceful shutdown with multiple bots
The current code calls `process.exit(0)` in the shutdown handler. With multiple bots, all shutdown functions must be awaited before exit. Need to collect them from `Promise.all` ‚Äî but `bot.start()` doesn't return until shutdown is requested. Pattern: `bot.start()` call is wrapped; the `shutdown()` function registered with signals calls `bot.stop()` externally, and the `bot.start()` Promise resolves.

> üìù Grammy's `bot.stop()` can be called from outside; `bot.start()` resolves after stop. So the CLI can hold refs to all `bot` instances and call `bot.stop()` on each from the signal handler.

**Revised approach:** `startBot()` returns a `{ ready: Promise<void>, stop: () => Promise<void> }` where `ready` resolves when the bot is running (via `onStart` callback) and `stop` calls `bot.stop()`. The CLI calls `Promise.all(bots.map(b => b.ready))` to confirm all are up, then sets up signal handlers calling `Promise.all(bots.map(b => b.stop()))`.

### Risk: .env loading per-project
Multiple `.env` files may define the same env var keys. Loading them sequentially could cause later projects' env vars to override earlier ones at the `process.env` level. Since we're dropping env var overrides in the new format, this only matters if the Claude CLI subprocess reads env vars. The `.env` files can still be loaded per project to set env vars that the Claude subprocess will inherit ‚Äî load them just before spawning the subprocess (in executor.ts) rather than at startup. For now, retain the existing "load at init time" behavior but document the limitation.

### Risk: `transcription` optional in project
If `transcription` is undefined (neither in project nor globals), the voice handler must handle this gracefully ‚Äî either disable voice handling or send an error reply. Current code already handles `config.transcription?.model`, so this is a minor check.

---

## Files Changed Summary

| File | Change Type |
|------|-------------|
| `src/config.ts` | Full rewrite |
| `src/logger.ts` | Full rewrite |
| `src/types.ts` | **New file** |
| `src/bot.ts` | Signature change + factory wiring |
| `src/cli.ts` | Multi-bot orchestration + new init template |
| `src/index.ts` | Update exports |
| `src/claude/executor.ts` | Accept `ProjectContext` |
| `src/transcription/whisper.ts` | Accept `ProjectContext` |
| `src/telegram/fileSender.ts` | Accept `ProjectContext` |
| `src/bot/middleware/auth.ts` | Factory function |
| `src/bot/middleware/rateLimit.ts` | Factory function, per-bot store |
| `src/bot/handlers/text.ts` | Factory function |
| `src/bot/handlers/photo.ts` | Factory function |
| `src/bot/handlers/document.ts` | Factory function |
| `src/bot/handlers/voice.ts` | Factory function |
| `src/bot/handlers/index.ts` | Update re-exports |
| `src/bot/commands/clear.ts` | Factory function |
| `src/bot/commands/start.ts` | No change |
| `src/bot/commands/help.ts` | No change |
| `src/telegram/chunker.ts` | No change |
| `src/user/setup.ts` | No change |
| `src/claude/parser.ts` | No change |
| `README.md` | Full rewrite |

---

## Execution Order

1. ‚úÖ Phase 1 ‚Äî Config schema & resolver
2. ‚úÖ Phase 2 ‚Äî Logger factory
3. ‚úÖ Phase 3 ‚Äî `types.ts`
4. ‚úÖ Phase 4 ‚Äî Services (executor, whisper, fileSender)
5. ‚úÖ Phase 5 ‚Äî Middleware factories
6. ‚úÖ Phase 6 ‚Äî Handler/command factories
7. ‚úÖ Phase 7 ‚Äî `bot.ts` refactor
8. ‚úÖ Phase 8 ‚Äî `cli.ts` orchestration
9. ‚úÖ Phase 9 ‚Äî `index.ts` exports + `examples/basic/ccpa.config.json`
10. ‚úÖ Phase 10 ‚Äî `README.md`
11. ‚úÖ `pnpm run build` + `pnpm run lint:fix` ‚Äî clean, no errors

## Completion Notes

- All 18 changed files compiled cleanly with `tsc`
- Biome lint: 0 errors, 0 warnings after removing unused `ctx` param in `checkClaudeCommand`
- The `examples/basic/ccpa.config.json` was updated to the new multi-project format for dev workflow
- `dotenv` dependency retained in package.json but no longer imported in config.ts (env var overrides removed per spec)
