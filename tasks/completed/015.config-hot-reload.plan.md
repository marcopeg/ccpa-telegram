# Plan: Config hot-reload

## Overview

When any hal config file in the config directory changes (`hal.config.json`, `hal.config.local.json`, `.env`, `.env.local`), stop all running bots gracefully, reload configuration, and start bots again for the (possibly changed) set of projects. The process keeps running; the config watcher is always on. Project-level files (per-project `.env`, commands, skills, hooks) are out of scope and use existing reload mechanisms.

## Affected Files

| File | Change |
|------|--------|
| `src/config.ts` | Add `tryLoadMultiConfig()` that throws instead of `process.exit(1)`; refactor `loadMultiConfig` to use shared logic |
| `src/cli.ts` | Extract `runBotsForConfig()`; add config watcher + reload loop; wire shutdown to close watcher |
| `src/config-watcher.ts` | **New** — chokidar-based watcher for the four config files, debounced callback |

---

## Phase 1 — Config load without process.exit ✅

**Goal:** Allow the reload path to attempt loading config and handle failure (log, retry on next change) instead of exiting the process.

**Step 1.1** ✅ — Extracted core loading into `loadMultiConfigInternal(configDir)`. Introduced `ConfigLoadError` and replaced all `console.error + process.exit(1)` with `throw new ConfigLoadError(...)` in resolveMessageTemplate, validateProjects, substituteEnvVars, loadLocalConfig, mergeLocalIntoBase, and the main load flow.

**Step 1.2** ✅ — `loadMultiConfig(configDir)` now calls internal in try/catch, logs and `process.exit(1)` on catch. Added and exported `tryLoadMultiConfig(configDir)` that returns the internal result (callers can try/catch).

**Step 1.3** ✅ — All helpers used from the internal path now throw; no process.exit in the internal path.

---

## Phase 2 — Extract "run bots for config" ✅

**Goal:** Reuse the same "load → resolve → start bots" flow for both initial start and reload, without duplicating logic.

**Step 2.1** ✅ — Extracted `runBotsForConfig(configDir, loaded: LoadedConfigResult, startupLogger): Promise<BotHandle[]>`; rejects if any bot fails to start.

**Step 2.2** ✅ — `runStart()` calls `loadMultiConfig(configDir)` then `runBotsForConfig(...)`; on reject, logs and `process.exit(1)`.

**Step 2.3** — Startup logger passed through; reload uses same logger in onConfigChange.

---

## Phase 3 — Config watcher module ✅

**Goal:** Watch only the four hal config files in the config directory and invoke a debounced callback on change.

**Step 3.1** ✅ — Created `src/config-watcher.ts`.

**Step 3.2** ✅ — Implemented `startConfigWatcher(configDir, onConfigChange): ConfigWatcherHandle` (four paths, chokidar, add/change/unlink, 400 ms debounce, stop() closes watcher and clears timer).

**Step 3.3** ✅ — Using `ignoreInitial: true`.

---

## Phase 4 — Wire reload loop and shutdown in CLI ✅

**Goal:** After the first successful start, start the config watcher. On debounced config change, stop all bots, reload config (without exiting), and start bots again. On SIGINT/SIGTERM, stop the watcher and all bots, then exit.

**Step 4.1** ✅ — Config watcher started after first run; onConfigChange logs "Config change detected", stops all handles, logs "All bots stopped", tryLoadMultiConfig + runBotsForConfig (assigns new handles), catch logs "Reload failed".

**Step 4.2** ✅ — `reloading` flag guards against concurrent reloads.

**Step 4.3** ✅ — Shutdown calls `configWatcher.stop()` then stops bots, then process.exit(0).

**Step 4.4** ✅ — Startup logger created once in runStart and used in onConfigChange.

---

## Phase 5 — Graceful stop and logging ✅

**Goal:** Confirm that in-flight requests complete before bots shut down, and that all required log points are present.

**Step 5.1** ✅ — `BotHandle.stop()` calls `bot.stop()` then awaits `runningPromise`. Grammy's `bot.stop()` stops polling and waits for in-flight updates to finish; comment added in `src/bot.ts`.

**Step 5.2** ✅ — Logging: "Config change detected", "All bots stopped", "Reload failed" (on error), "All bots running" (from runBotsForConfig) with count.

---

## Phase 6 — Testing and edge cases

**Step 6.1** — Manual test: start the app, edit `hal.config.json` (e.g. change a project name or add a project), save; expect bots to stop and new set to start, with logs as above.

**Step 6.2** — Manual test: introduce an invalid config (e.g. invalid JSON or schema), save; expect "reload failed" log, no crash, and no bots running until config is fixed and saved again.

**Step 6.3** — Manual test: SIGINT during normal run and during reload; expect watcher and bots to stop and process to exit.

**Step 6.4** — Optional: add a simple test or script that touches the four config files and asserts the watcher fires (if the project has tests for the CLI).

---

## Summary

| Phase | Description |
|-------|-------------|
| 1 | Config load without process.exit: internal throw-based loader + `tryLoadMultiConfig` |
| 2 | Extract `runBotsForConfig()` from `runStart()` |
| 3 | New `config-watcher.ts`: chokidar, four files, debounce, `stop()` |
| 4 | CLI: start watcher after first run; reload callback (stop → try load → run bots); shutdown closes watcher; re-entrancy guard |
| 5 | Verify graceful stop; ensure all required logs |
| 6 | Manual (and optional automated) testing |

Dependencies: Phase 1 first (reload needs tryLoadMultiConfig). Phase 2 can be done in parallel or right after. Phase 3 is independent. Phase 4 depends on 1, 2, 3. Phase 5 and 6 after 4.
