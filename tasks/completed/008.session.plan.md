# Task 008 — Session continuity & renewal commands: Implementation Plan

## Complexity assessment: **Medium**

The session plumbing already exists for Claude (session ID storage + `--resume`). The work is mostly config-schema expansion, adapter-level branching, two new built-in commands, and a small manifest change. No new dependencies are needed.

---

## Phase 1 — Config schema: `engine.session` & `engine.sessionMsg` ✅

### Step 1.1 — Extend Zod schemas in `src/config.ts` ✅

Add `session` (boolean) and `sessionMsg` (string) to `EngineConfigSchema`:

```ts
const EngineConfigSchema = z
  .object({
    name: EngineNameSchema,
    command: z.string(),
    model: z.string(),
    session: z.boolean(),
    sessionMsg: z.string(),
  })
  .partial()
  .optional();
```

Both fields are `.partial()` so they remain optional in the JSON file.

### Step 1.2 — Expose resolved values in `ResolvedProjectConfig` ✅

Add two new fields to the `ResolvedProjectConfig` interface:

```ts
engineSession: boolean;      // project.engine.session ?? globals.engine.session ?? true
engineSessionMsg: string;    // project.engine.sessionMsg ?? globals.engine.sessionMsg ?? "hi!"
```

Update `resolveProjectConfig()` to merge project → globals → defaults, following the same pattern as `engineModel`.

### Step 1.3 — Update example config ✅

Add `"session": true` to the engine block in `examples/hal.config.json` as documentation.

---

## Phase 2 — Adapter session behaviour ✅

### Step 2.1 — Thread `engineSession` into `EngineExecuteOptions` ✅

The text handler currently reads the stored `sessionId` and passes it to `engine.execute()`. That flow needs to become conditional on `config.engineSession`:

**`src/bot/handlers/text.ts`** (and `photo.ts`, `document.ts`, `voice.ts` if they pass `sessionId`):

```ts
const sessionId = config.engineSession
  ? await getSessionId(userDir)
  : null;
```

And after execution:

```ts
if (config.engineSession && result.sessionId) {
  await saveSessionId(userDir, result.sessionId);
}
```

This ensures that when `session=false`, no session ID is read, written, or passed.

### Step 2.2 — Update Claude adapter (`src/engine/adapters/claude.ts`) ✅

The Claude adapter already gates `--resume` on `if (sessionId)`. Because step 2.1 now passes `null` when `session=false`, no changes are needed inside the adapter itself — the session gating is handled by the caller. No adapter-level changes required.

### Step 2.3 — Update Copilot adapter (`src/engine/adapters/copilot.ts`) ✅

Replace the current `--resume <sessionId>` logic with a `--continue` flag driven by config:

1. Remove the `sessionId` destructuring from `options`.
2. Read `config.engineSession` from `ctx.config`.
3. If `engineSession === true`, push `"--continue"` into the args array.
4. If `engineSession === false`, do nothing (no `--continue`, no `--resume`).

The adapter no longer reads or cares about `sessionId` at all — Copilot manages sessions internally via `--continue`.

### Step 2.4 — Codex / OpenCode adapters (no-op) ✅

No changes. These stubs do not use `sessionId` today and the new config fields are silently ignored.

---

## Phase 3 — Session renewal commands (`/new` and `/clean`) ✅

### Step 3.1 — Add `clearSessionData()` to `src/user/setup.ts` ✅

Create a new function that deletes only `session.json` without touching uploads/downloads:

```ts
export async function clearSessionData(userDir: string): Promise<void> {
  const sessionFile = join(userDir, "session.json");
  try {
    await rm(sessionFile, { force: true });
  } catch {
    // Ignore — file may not exist
  }
}
```

### Step 3.2 — Create `src/bot/commands/session.ts` ✅

New file with a factory function that returns a Grammy handler:

```ts
export function createSessionHandler(ctx: ProjectContext) {
  return async (gramCtx: Context): Promise<void> => { ... };
}
```

Logic:

1. Resolve `userDir` from `ctx.config.dataDir` + `gramCtx.from.id`.
2. Call `clearSessionData(userDir)` (always — even when `session=false`).
3. **If engine is `"copilot"`** — perform active reset:
   - Create an Agent via `createAgent(ctx)`.
   - Call `agent.call(ctx.config.engineSessionMsg)`.
   - Reply with the engine's response via `sendChunkedResponse()`.
4. **Otherwise** (Claude, Codex, OpenCode) — passive reset:
   - Reply with `"New session started."`.

### Step 3.3 — Register `/new` and `/clean` in `src/bot.ts` ✅

Import `createSessionHandler` and wire both commands to the same handler:

```ts
const sessionHandler = createSessionHandler(projectCtx);
bot.command("new", sessionHandler);
bot.command("clean", sessionHandler);
```

---

## Phase 4 — Telegram command manifest ✅

### Step 4.1 — Define built-in command list in `src/bot/commands/loader.ts` ✅

Add a constant array of built-in commands:

```ts
export const BUILTIN_COMMANDS: CommandEntry[] = [
  { command: "start",  description: "Welcome message",           filePath: "" },
  { command: "help",   description: "Show help",                 filePath: "" },
  { command: "clear",  description: "Clear conversation history", filePath: "" },
  { command: "new",    description: "Start a new session",       filePath: "" },
  { command: "clean",  description: "Start a new session",       filePath: "" },
];
```

### Step 4.2 — Prepend built-ins in `loadCommands()` ✅

At the start of the `loadCommands()` function, seed the `map` with `BUILTIN_COMMANDS` before inserting skill / global / project entries. This ensures built-ins are always present but can still be overridden by custom commands if desired.

### Step 4.3 — Update watcher `republish()` (no code changes needed) ✅

The watcher already calls `loadCommands()` and publishes the full result. Since `loadCommands()` now includes built-ins, the watcher will automatically include `/new` and `/clean` on every republish.

### Step 4.4 — Update initial registration in `src/bot.ts` ✅

The startup registration block in `bot.ts` currently skips `setMyCommands` when `commands.length === 0`. Since built-ins are now always present this condition will always be true, but the guard can remain as-is.

---

## Phase 5 — Validation & cleanup ✅

### Step 5.1 — Build check ✅

Run `pnpm run build` to verify TypeScript compilation.

### Step 5.2 — Lint check ✅

Run `pnpm run lint` and fix any issues.

### Step 5.3 — Manual verification checklist

- [ ] `hal.config.json` with `"session": true` + Copilot engine → messages include `--continue`
- [ ] `hal.config.json` with `"session": false` + Copilot engine → messages do NOT include `--continue`
- [ ] `hal.config.json` with `"session": false` + Claude engine → `--resume` not passed, `session.json` not read/written
- [ ] `/new` or `/clean` with Claude → `session.json` deleted, static reply
- [ ] `/new` or `/clean` with Copilot → engine receives `sessionMsg` without `--continue`, reply shows engine output
- [ ] `/new` and `/clean` appear in Telegram command suggestions on startup
- [ ] `/new` and `/clean` appear after hot-reload via command watcher

---

## Files changed (summary)

| File | Change |
|------|--------|
| `src/config.ts` | Add `session`, `sessionMsg` to schema + resolved config |
| `src/bot/handlers/text.ts` | Gate `getSessionId` / `saveSessionId` on `engineSession` |
| `src/bot/handlers/photo.ts` | Same session gating (if it passes sessionId) |
| `src/bot/handlers/document.ts` | Same session gating (if it passes sessionId) |
| `src/bot/handlers/voice.ts` | Same session gating (if it passes sessionId) |
| `src/engine/adapters/copilot.ts` | Replace `--resume <id>` with `--continue` based on config |
| `src/user/setup.ts` | Add `clearSessionData()` |
| `src/bot/commands/session.ts` | **New** — `/new` and `/clean` handler |
| `src/bot/commands/loader.ts` | Add `BUILTIN_COMMANDS`, seed in `loadCommands()` |
| `src/bot.ts` | Import + register `/new` and `/clean` |
| `examples/hal.config.json` | Add `session` field for documentation |
