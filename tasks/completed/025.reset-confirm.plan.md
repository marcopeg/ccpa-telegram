# 025 — Plan: Confirm /reset before deleting user data

> **Execution status:** All phases completed. Build passes (`tsc --noEmit` clean).

## Phase 1: Extend config with `commands.reset.timeout` ✅

### Step 1.1 — New Zod schema for reset command

In `src/config.ts`, create a `ResetCommandConfigSchema` that extends `SimpleCommandConfigSchema` with a `timeout` field (positive number, optional). Replace the `reset` entry in `CommandsConfigSchema` with it.

```typescript
const ResetCommandConfigSchema = z
  .object({
    enabled: z.boolean().optional(),
    message: CommandMessageSchema.optional(),
    timeout: z.number().positive().optional(),
  })
  .optional();
```

Update `CommandsConfigSchema` to use `ResetCommandConfigSchema` for the `reset` key.

### Step 1.2 — Add `timeout` to `ResolvedProjectConfig`

Extend `commands.reset` in the `ResolvedProjectConfig` interface:

```typescript
reset: { enabled: boolean; message?: string; timeout: number };
```

### Step 1.3 — Resolve the timeout in `resolveProjectConfig`

In the `resolvedCommands` construction, resolve `timeout` with the standard project > globals > default (60) cascade:

```typescript
reset: {
  enabled: ...,
  message: ...,
  timeout: rawReset?.timeout ?? 60,
},
```

**Files changed:** `src/config.ts`

---

## Phase 2: Create the reset confirmation prompt tracker ✅

### Step 2.1 — New module `src/bot/commands/resetPrompt.ts`

Create a module that manages active reset prompts. This holds:

- An in-memory `Map<number, ActivePrompt>` keyed by userId, where `ActivePrompt` stores `{ chatId, messageId, timer }`.
- `trackPrompt(userId, chatId, messageId, timeoutMs, bot)` — stores the prompt and starts a `setTimeout` that edits the message to remove the inline keyboard on expiry.
- `invalidatePrompt(userId, bot)` — if an active prompt exists for that user, cancels its timer, edits the message to remove buttons (marks as expired), and removes the entry from the map.
- `resolvePrompt(userId)` — removes the entry from the map and cancels its timer (called after confirm/abort).
- `clearAllPrompts()` — cancels all timers (for bot shutdown cleanup).

The `bot` parameter is the Grammy `Bot.api` (or pass the `Api` instance directly) so the tracker can call `editMessageReplyMarkup` on expiry/invalidation without needing the callback context.

**Files created:** `src/bot/commands/resetPrompt.ts`

---

## Phase 3: Rewrite the `/reset` command handler ✅

### Step 3.1 — Replace immediate deletion with confirmation prompt

Rewrite `createResetHandler` in `src/bot/commands/reset.ts`:

1. Identify `userId` (unchanged).
2. Call `invalidatePrompt(userId, bot.api)` to cancel any prior active prompt.
3. Build an `InlineKeyboard` with two buttons:
   - `Yes, go ahead!` → callback data `r:y:<userId>`
   - `Abort!` → callback data `r:n:<userId>`
4. Send the warning message with the inline keyboard.
5. Call `trackPrompt(userId, chatId, messageId, config.commands.reset.timeout * 1000, bot.api)`.

The handler factory now also needs the `Bot` API reference to pass to the tracker. Update the signature to `createResetHandler(ctx: ProjectContext, botApi: Api)`.

**Files changed:** `src/bot/commands/reset.ts`

---

## Phase 4: Create the reset callback query handler ✅

### Step 4.1 — New handler for `r:` prefixed callbacks

Create `createResetCallbackHandler(ctx: ProjectContext)` in `src/bot/commands/reset.ts` (co-located with the command handler). This follows the same pattern as the git callback handler:

1. Read `callbackQuery.data`.
2. If it doesn't start with `r:`, call `next()` to pass through.
3. Parse the action (`y` or `n`) and userId from the data.
4. Verify that `gramCtx.from.id` matches the userId embedded in the callback data (prevents other users from tapping someone else's buttons).
5. Call `resolvePrompt(userId)` to clean up tracking/timers.
6. **On confirm (`r:y:<userId>`):**
   - Delete user data via `clearUserData(userDir)`.
   - Edit the message to a hardcoded success text (e.g. `"All user data wiped. Your next message starts fresh."`) with `reply_markup: undefined`.
7. **On abort (`r:n:<userId>`):**
   - Edit the message to `"Reset cancelled."` with `reply_markup: undefined`.
8. Call `answerCallbackQuery()` in all paths.
9. Wrap in try/catch with logging (same pattern as git callback).

**Files changed:** `src/bot/commands/reset.ts`

---

## Phase 5: Wire into `bot.ts` ✅

### Step 5.1 — Register the reset callback handler

In `startBot()` in `src/bot.ts`:

1. Import `createResetCallbackHandler` from `./bot/commands/reset.js`.
2. After registering the `/reset` command, register the callback handler:
   ```typescript
   bot.on("callback_query:data", createResetCallbackHandler(projectCtx));
   ```
3. Pass `bot.api` to `createResetHandler` so it can invalidate/track prompts.

The reset callback handler calls `next()` for non-`r:` data, so it coexists with the git callback handler regardless of registration order.

### Step 5.2 — Clean up timers on bot shutdown

Import `clearAllPrompts` from `resetPrompt.ts` and call it in the `stop()` function of the bot handle, before `bot.stop()`.

**Files changed:** `src/bot.ts`

---

## Summary of files

| File | Action |
|------|--------|
| `src/config.ts` | Modify — add `timeout` to reset schema + resolved config |
| `src/bot/commands/resetPrompt.ts` | Create — prompt tracker (Map, timers, invalidation) |
| `src/bot/commands/reset.ts` | Rewrite — confirmation prompt + callback handler |
| `src/bot.ts` | Modify — wire callback handler, pass API, cleanup |
