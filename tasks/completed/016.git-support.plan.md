# Plan: Git support (global commands)

## Phase 1 — Config: `enabled` flag + git entry ✅

Extend the Zod schemas and resolved config to support per-command `enabled` booleans and the new `git` group.

### Step 1.1 — Update Zod schemas in `src/config.ts`

- Add `enabled: z.boolean().optional()` to `StartConfigSchema` (alongside `session` and `message`).
- Add `enabled: z.boolean().optional()` to `SimpleCommandConfigSchema` (alongside `message`).
- Create `GitConfigSchema = z.object({ enabled: z.boolean().optional() }).optional()`.
- Add `git: GitConfigSchema` to `CommandsConfigSchema`.

Result:

```ts
const StartConfigSchema = z
  .object({
    enabled: z.boolean().optional(),
    session: z.object({ reset: z.boolean() }).partial().optional(),
    message: CommandMessageSchema,
  })
  .optional();

const SimpleCommandConfigSchema = z
  .object({
    enabled: z.boolean().optional(),
    message: CommandMessageSchema,
  })
  .optional();

const GitConfigSchema = z
  .object({
    enabled: z.boolean().optional(),
  })
  .optional();

const CommandsConfigSchema = z
  .object({
    start: StartConfigSchema,
    help: SimpleCommandConfigSchema,
    reset: SimpleCommandConfigSchema,
    clean: SimpleCommandConfigSchema,
    git: GitConfigSchema,
  })
  .optional();
```

### Step 1.2 — Update `ResolvedProjectConfig`

Add `enabled` booleans to each command entry and a new `git` entry in the `commands` type:

```ts
commands: {
  start: { enabled: boolean; sessionReset: boolean; message?: string };
  help:  { enabled: boolean; message?: string };
  reset: { enabled: boolean; message?: string };
  clean: { enabled: boolean; message?: string };
  git:   { enabled: boolean };
};
```

All command entries are always present (not optional) because we resolve defaults. `message` becomes optional because users may only set `enabled` without customizing the message.

### Step 1.3 — Update `resolveProjectConfig()`

Resolve each command's `enabled` state with defaults (`true` for start/help/reset/clean, `false` for git). Use the existing project-over-globals fallback pattern.

For each built-in command:
- `enabled`: `project.commands?.X?.enabled ?? globals.commands?.X?.enabled ?? DEFAULT`
- `message` and other fields: resolved as before, but only when the raw config provides them.

For git:
- `enabled`: `project.commands?.git?.enabled ?? globals.commands?.git?.enabled ?? false`

---

## Phase 2 — Loader: source tracking + enabled filtering ✅

Modify `CommandEntry` and the loader to track where each command comes from, and to respect enabled flags.

### Step 2.1 — Add `source` field to `CommandEntry`

In `src/bot/commands/loader.ts`, extend the `CommandEntry` interface:

```ts
export interface CommandEntry {
  command: string;
  description: string;
  filePath: string;
  skillPrompt?: string;
  public?: boolean;
  source: "builtin" | "git" | "project" | "system" | "skill";
}
```

### Step 2.2 — Tag existing entries with source

- `BUILTIN_COMMANDS`: add `source: "builtin"` to each entry.
- `scanCommandDir()`: accept a `source` parameter (`"project"` or `"system"`), set it on each returned entry.
- `scanSkillsDir()`: set `source: "skill"` on each returned entry.

### Step 2.3 — Add git commands to the loader

Define a `GIT_COMMANDS` constant (similar to `BUILTIN_COMMANDS`):

```ts
export const GIT_COMMANDS: CommandEntry[] = [
  { command: "git_init",   description: "Initialize a git repository", filePath: "", source: "git" },
  { command: "git_status", description: "Show git status",             filePath: "", source: "git" },
  { command: "git_commit", description: "Commit changes",              filePath: "", source: "git" },
  { command: "git_clean",  description: "Revert uncommitted changes",  filePath: "", source: "git" },
];
```

### Step 2.4 — Update `loadCommands()` signature and logic

Pass the resolved commands config (or at minimum the enabled states) to `loadCommands()`:

```ts
interface CommandEnabledFlags {
  start: boolean;
  help: boolean;
  reset: boolean;
  clean: boolean;
  git: boolean;
}

export async function loadCommands(
  projectCwd: string,
  configDir: string,
  logger: pino.Logger,
  skillsDir?: string,
  enabled?: CommandEnabledFlags,
): Promise<CommandEntry[]>
```

Inside `loadCommands()`:
- Seed `BUILTIN_COMMANDS` as before, then seed `GIT_COMMANDS` (only when `enabled.git` is true).
- After building the full map, filter out entries whose command name maps to a disabled flag (e.g., if `enabled.start === false`, remove the `start` entry).
- Pass `"project"` or `"system"` source to `scanCommandDir()` calls.

### Step 2.5 — Export `GIT_COMMANDS` for help grouping

Export both `BUILTIN_COMMANDS` and `GIT_COMMANDS` so `buildHalCommands()` can use them for classification.

---

## Phase 3 — Bot wiring: conditional handler registration ✅

### Step 3.1 — Conditional handler wiring in `src/bot.ts`

Replace the unconditional `bot.command(...)` calls with conditional ones:

```ts
const cmd = config.commands;

if (cmd.start.enabled) bot.command("start", createStartHandler(projectCtx));
if (cmd.help.enabled)  bot.command("help",  createHelpHandler(projectCtx));
if (cmd.reset.enabled) bot.command("reset", createResetHandler(projectCtx));
if (cmd.clean.enabled) bot.command("clean", createCleanHandler(projectCtx));

if (cmd.git.enabled) {
  bot.command("git_init",   createGitInitHandler(projectCtx));
  bot.command("git_status", createGitStatusHandler(projectCtx));
  bot.command("git_commit", createGitCommitHandler(projectCtx));
  bot.command("git_clean",  createGitCleanHandler(projectCtx));
  bot.on("callback_query:data", createGitCallbackHandler(projectCtx));
}
```

### Step 3.2 — Pass enabled flags to `loadCommands()` and watcher

Update the `loadCommands()` call in `bot.ts` to pass enabled flags from config.

Update `startCommandWatcher()` to accept and forward enabled flags so `republish()` filters correctly.

---

## Phase 4 — Help: section reordering ✅

### Step 4.1 — Update `buildHalCommands()` in `src/bot/commands/message.ts`

Replace the current 3-way classification with 5-way classification using the `source` field:

```ts
const projectCommands: CommandEntry[] = [];  // source === "project"
const skills: CommandEntry[] = [];           // source === "skill" && public
const systemCommands: CommandEntry[] = [];   // source === "system"
const halCommands: CommandEntry[] = [];      // source === "builtin"
const gitCommands: CommandEntry[] = [];      // source === "git"

for (const entry of all) {
  switch (entry.source) {
    case "project":  projectCommands.push(entry); break;
    case "skill":    if (entry.public) skills.push(entry); break;
    case "system":   systemCommands.push(entry); break;
    case "builtin":  halCommands.push(entry); break;
    case "git":      gitCommands.push(entry); break;
  }
}
```

### Step 4.2 — Render sections in the new order

```ts
const sections: string[] = [];

if (projectCommands.length > 0)
  sections.push(`*Project Commands:*\n${formatCommandList(projectCommands)}`);
if (skills.length > 0)
  sections.push(`*Project Skills:*\n${formatCommandList(skills)}`);
if (systemCommands.length > 0)
  sections.push(`*System Commands:*\n${formatCommandList(systemCommands)}`);
if (halCommands.length > 0)
  sections.push(`*Hal Commands:*\n${formatCommandList(halCommands)}`);
if (gitCommands.length > 0)
  sections.push(`*Git Commands:*\n${formatCommandList(gitCommands)}`);
```

Disabled commands are already filtered out by `loadCommands()` (Phase 2), so no extra filtering needed here.

---

## Phase 5 — Git commands: init, status, commit ✅

### Step 5.1 — Create shared git utility `src/bot/commands/git/exec.ts`

Helper to run git commands in the project directory:

```ts
import { execFile } from "node:child_process";
import { promisify } from "node:util";

const execFileAsync = promisify(execFile);

export async function gitExec(
  cwd: string,
  args: string[],
): Promise<{ stdout: string; stderr: string }> {
  return execFileAsync("git", args, { cwd, timeout: 30_000 });
}

export async function isGitRepo(cwd: string): Promise<boolean> {
  try {
    await gitExec(cwd, ["rev-parse", "--is-inside-work-tree"]);
    return true;
  } catch {
    return false;
  }
}
```

### Step 5.2 — `/git_init` handler `src/bot/commands/git/init.ts`

- Check `isGitRepo(config.cwd)`.
- If already a repo: reply "Already a git repository."
- If not: run `git init`, then `git add .`, then `git commit -m "Initial commit"`.
- Reply with confirmation.

### Step 5.3 — `/git_status` handler `src/bot/commands/git/status.ts`

- Run `git status` in `config.cwd`.
- Format the output (wrap in monospace block for readability).
- Reply with the formatted output.

### Step 5.4 — `/git_commit` handler `src/bot/commands/git/commit.ts`

- Parse optional message argument from the command text.
- Run `git add .` to stage all changes.
- If a message is provided: run `git commit -m "<message>"`.
- If no message: run `git diff --cached` and `git status`, pass the output to `createAgent(ctx).call(...)` with a prompt asking for a short commit message, then commit with the generated message.
- Reply with the commit result (hash, message summary).
- Handle edge cases: no changes to commit, empty diff.

---

## Phase 6 — Git clean: inline keyboard + callback queries ✅

### Step 6.1 — `/git_clean` handler `src/bot/commands/git/clean.ts`

**When a file argument is provided:**
- Validate the file has uncommitted changes (check against `git status --short`).
- Run `git restore <file>`.
- Reply with confirmation.

**When no argument is provided:**
- Run `git status --short` to get the list of changed files.
- If no changes: reply "Working tree is clean."
- Build an inline keyboard with one button per file + a "Reset all" button.
- Each button's `callback_data`: `gc:select:<filename>` for single files, `gc:all` for reset all.
- Send the file list message with the inline keyboard.

### Step 6.2 — Callback query handler `src/bot/commands/git/callback.ts`

Handle `callback_query:data` events where data starts with `gc:`:

**Selection callbacks (`gc:select:<file>` and `gc:all`):**
- Build a confirmation message listing the file(s) to be reverted.
- Edit the original message (or send a new one) with Confirm/Cancel inline keyboard.
- `callback_data`: `gc:confirm:<file_or_all>` and `gc:cancel`.

**Confirm callback (`gc:confirm:<target>`):**
- Run `git restore <file>` (or `git restore .` for all).
- Edit message to show success confirmation.
- Answer the callback query.

**Cancel callback (`gc:cancel`):**
- Edit message to show "Cancelled."
- Answer the callback query.

### Step 6.3 — Wire callback handler in `bot.ts`

Already covered in Phase 3 Step 3.1. The `createGitCallbackHandler` is registered when git is enabled:

```ts
bot.on("callback_query:data", createGitCallbackHandler(projectCtx));
```

The handler should check the `gc:` prefix and ignore unrelated callback queries (call `next()` or return early) so other callback handlers can coexist in the future.

---

## Execution notes

- Phase 1: Also made `message` optional in `StartConfigSchema` and `SimpleCommandConfigSchema` so users can set `enabled` without providing a message. Updated all 4 command handlers (`start.ts`, `help.ts`, `reset.ts`, `session.ts`) to remove optional chaining on the now-always-present command configs.
- Phases 3, 5, 6: Implemented together since bot.ts needed the git handler imports to compile. All git command handlers (`init`, `status`, `commit`, `clean`, `callback`) were created in `src/bot/commands/git/`.
- Phase 4: Removed the `BUILTIN_NAMES` set (no longer needed); `buildHalCommands()` now classifies purely by `entry.source` field. Also passes `enabled` flags to `loadCommands()` so disabled commands are filtered before grouping.

## Phase summary

| Phase | Files touched | Depends on |
|-------|--------------|------------|
| 1. Config | `src/config.ts` | — |
| 2. Loader | `src/bot/commands/loader.ts` | Phase 1 |
| 3. Bot wiring | `src/bot.ts`, `src/bot/commands/watcher.ts` | Phase 1, 2 |
| 4. Help | `src/bot/commands/message.ts` | Phase 2 |
| 5. Git commands | `src/bot/commands/git/exec.ts`, `git/init.ts`, `git/status.ts`, `git/commit.ts` | Phase 1 |
| 6. Git clean | `src/bot/commands/git/clean.ts`, `git/callback.ts`, `src/bot.ts` | Phase 5 |
