# Plan — Task 003: Context injection

Progress legend: `[ ]` pending · `[x]` done · `[-]` skipped

---

## Phase 1 — Config schema: add `context` field

**Goal:** Accept `context: Record<string, string>` in both `globals` and per-project config, with merging/inheritance.

### Steps

- [x] **1.1** Add `context: z.record(z.string(), z.string()).optional()` to `GlobalsFileSchema`, `ProjectFileSchema`, and `LocalProjectSchema` in `src/config.ts`.
  > Added to GlobalsFileSchema and ProjectFileSchema. LocalProjectSchema inherits via `.partial()`.

- [x] **1.2** Add `context: Record<string, string> | undefined` to `ResolvedProjectConfig`. In `resolveProjectConfig()`, merge globals context + project context (project wins) using spread: `{ ...globals.context, ...project.context }`. Store `undefined` if neither defines it.
  > Also added `configDir: string` to `ResolvedProjectConfig` (needed for Phase 5 — global hook path resolution).

- [x] **1.3** Update the `ccpa init` template in `src/cli.ts` to include a commented-out example `context` block in the generated `ccpa.config.json`.
  > Added as a code comment below the template constant rather than in the JSON itself, to keep the init output clean.

---

## Phase 2 — Variable substitution patterns (`#{}` and `@{}`)

**Goal:** Implement the three substitution patterns for context values: `${}` (env/app vars, already exists for env), `#{}` (boot-time shell), `@{}` (message-time shell).

### Steps

- [x] **2.1** Create `src/context/resolver.ts` with the context resolution module. Export types:
  ```ts
  interface BootContext {
    shellCache: Record<string, string>       // #{} results evaluated once
  }
  ```

- [x] **2.2** Implement `evaluateBootTimeShells(context: Record<string, string>): Record<string, string>` — scans all context values for `#{...}` patterns, runs each via `execSync`, caches and replaces inline. Called once at startup. On failure, log warning and substitute empty string.

- [x] **2.3** Implement `evaluateMessageTimeShells(value: string): string` — replaces `@{...}` patterns in a single string value by running the command via `execSync` at call time. On failure, log warning and substitute empty string.

- [x] **2.4** Implement `resolveAppVars(value: string, vars: Record<string, string>): string` — replaces `${expression}` patterns by looking up `expression` in the provided variable map (which includes `bot.*`, `sys.*`, and env vars). This is distinct from the config-level env substitution (Phase 4 of task 002) which runs before Zod validation; this one runs at message time on context values only.

---

## Phase 3 — Implicit context and message-time resolution

**Goal:** Build the full context object at message time from implicit defaults + config + substitution + hook.

### Steps

- [x] **3.1** Implement `buildImplicitContext(gramCtx: GrammyContext): Record<string, string>` in `src/context/resolver.ts`. Extracts all `bot.*` keys from the Grammy context object:
  - `bot.messageId`, `bot.timestamp`, `bot.datetime`, `bot.userId`, `bot.username`, `bot.firstName`, `bot.chatId`, `bot.messageType`

- [x] **3.2** Implement `buildSystemContext(): Record<string, string>` for `sys.*` keys:
  - `sys.datetime`, `sys.date`, `sys.time`, `sys.ts`, `sys.tz`
  - All evaluated fresh per call.

- [x] **3.3** Implement `resolveContext(options: ResolveContextOptions): Promise<Record<string, string>>` — the main orchestrator:
  1. Start with implicit context (`bot.*` + `sys.*`)
  2. Merge config context on top (config wins for explicit overrides)
  3. Resolve `${...}` app vars in all values (using the combined implicit + env var map)
  4. Resolve `@{...}` message-time shell commands in all values
  5. Apply boot-time `#{}` cached replacements (already resolved at boot)
  6. Run global hook (`{configDir}/.ccpa/hooks/context.mjs`) — hot-reloaded
  7. Run project hook (`{project.cwd}/.ccpa/hooks/context.mjs`) — hot-reloaded
  8. Return final `Record<string, string>`

- [x] **3.4** Implement `formatContextPrompt(context: Record<string, string>, userMessage: string): string` — formats the final prompt:
  ```
  # Context
  - key1: value1
  - key2: value2

  # User Message
  {userMessage}
  ```

---

## Phase 4 — Context hooks (two-level, hot-reloaded)

**Goal:** Support two chained hook files — global (`{configDir}/.ccpa/hooks/context.mjs`) and project (`{project.cwd}/.ccpa/hooks/context.mjs`) — both hot-reloaded on every message.

### Steps

- [x] **4.1** Implement `loadAndRunHook(hookPath: string, context: Record<string, string>, logger: Logger): Promise<Record<string, string>>` in `src/context/resolver.ts`.
  - Checks `existsSync(hookPath)` — if missing, return context unchanged (silently skip).
  - Uses `import(`${hookPath}?t=${Date.now()}`)` to bypass Node.js module cache (hot-reload).
  - Calls the default export with the context, awaits result.
  - On any error (import or execution), log warning and return the pre-hook context.

- [x] **4.2** Integrate both hooks into `resolveContext()` in chain order:
  1. Run global hook: `loadAndRunHook(join(configDir, ".ccpa/hooks/context.mjs"), context, logger)`
  2. Run project hook: `loadAndRunHook(join(projectCwd, ".ccpa/hooks/context.mjs"), context, logger)`
  - Either or both may be absent — each is independent and optional.

---

## Phase 5 — Boot-time initialization

**Goal:** Evaluate `#{}` shell commands at startup and make `configDir` available at message time for global hook resolution.

### Steps

- [x] **5.1** Add `bootContext: BootContext` to `ProjectContext` interface in `src/types.ts`. The `BootContext` type only contains `shellCache` (no hook reference — hooks are hot-reloaded per message). Also add `configDir: string` to `ResolvedProjectConfig` so the executor can locate the global hook path.

- [x] **5.2** In `src/cli.ts` → `runStart`, after `resolveProjectConfig()`:
  1. Evaluate `#{}` shell commands in the project's merged context → `shellCache`
  2. Construct `BootContext { shellCache }` and include it in `ProjectContext`
  3. Ensure `configDir` is passed through to `ResolvedProjectConfig`
  > `configDir` is already passed to `resolveProjectConfig()` and is now stored in the returned config.

---

## Phase 6 — Wire handlers to pass Grammy context through to executor

**Goal:** All message handlers pass Grammy context to the executor so `bot.*` variables can be resolved.

### Steps

- [x] **6.1** Add `gramCtx?: GrammyContext` to `ExecuteOptions` in `src/claude/executor.ts`.

- [x] **6.2** In `executeClaudeQuery()`, if `gramCtx` is provided:
  1. Call `resolveContext()` with Grammy context, boot context, and config context
  2. Call `formatContextPrompt()` to wrap the prompt with context header
  3. Use the formatted prompt instead of the raw prompt for the `-p` flag

- [x] **6.3** Update all four handlers (`text.ts`, `photo.ts`, `document.ts`, `voice.ts`) to pass `gramCtx` in `ExecuteOptions` when calling `executeClaudeQuery`.

---

## Phase 7 — Examples and init template

**Goal:** Update examples to demonstrate context configuration.

### Steps

- [x] **7.1** Update `examples/ccpa.config.json` to include a `context` block in globals showing `${bot.messageId}`, `${bot.datetime}`, and `${sys.datetime}`.

- [x] **7.2** Add an example `.ccpa/hooks/context.mjs` in the examples directory demonstrating a simple global hook.

---

## Phase 8 — Lint & typecheck

- [x] **8.1** Run `pnpm run lint:fix` — Biome fixed 3 files (import formatting).
- [x] **8.2** Run `pnpm run build` — TypeScript compiled clean, no errors.

---

## Notes

- No new npm dependencies needed. Uses `execSync` from `node:child_process` for shell commands, `import()` for hook loading.
- The existing `substituteEnvVars()` in `src/config.ts` handles `${VAR}` at config-load time (before Zod). The new `resolveAppVars()` handles `${bot.X}`, `${sys.X}` at message time in context values only — these are separate concerns.
- `#{}` boot-time shells are evaluated once and their results replace the pattern in the cached context values. At message time, only `${}` and `@{}` need per-message evaluation.
- Grammy `Context` type is imported from `grammy` — already a project dependency.
- Both hooks use `.mjs` extension to guarantee ESM regardless of project `package.json` type field.
- Hooks are hot-reloaded via `import(`${path}?t=${Date.now()}`)` on every message — no restart needed. This means Claude Code (or any process) can create/modify hooks at runtime.
- `configDir` must be stored in `ResolvedProjectConfig` so the executor can resolve the global hook path at message time.
- Security: shell commands (`#{}`, `@{}`) and hooks only come from operator-controlled config/files, never from user messages.
